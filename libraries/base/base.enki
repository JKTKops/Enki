true if 1 = 1.
false if 1 = 2.

- X is 0 - X.

display X where writeln X.

as text X is term_to_atom X.

map F over Xs is map_built_in F Xs.
filter Xs with F is filter_built_in F Xs.

either P or Q holds for X if disjunction_built_in P Q X.

one of Ps holds for X if one_of_built_in Ps X.

number of characters in T is atom_length T.

only elements of List satisfying F is filter List with F.

call F on X is call_built_in F X.

call rule R on X is call_rule_built_in R X.

the X is X.
id X is X.

odd X if X = 2*K + 1.
even X if X = 2*K.

square root X is (Root^2) = X, Root.

A divides B if B = A*N.

list A may be
    empty.
    cons Head Tail has
        Head : A,
        Tail : list A.

prepend Head to Tail is cons Head Tail.

pair A B may be
    pair X and Y has X : A, Y : B.

list of length N is
    when N <= 0 then empty.
    otherwise then prepend NewElem to list of length (N - 1).

length of List is
    when List = cons H T then 1 + length of T.
    otherwise then 0.

construct Head Full is
    Full = cons Head Tail,
    Tail.

concat A with B is
    when A = cons H T then prepend H to concat T with B.
    otherwise then B.

flatten List is
    when List = cons H T then concat H with flatten T.
    otherwise then empty.

reverseAcc A Acc is
    when A = cons H T then reverseAcc T (cons H Acc).
    otherwise then Acc.

reverse list A is reverseAcc A empty.

sum of List is
    when List = cons H T then H + sum of T.
    otherwise then 0.

multiples of A in List is filter List with (A divides _).

formatHelper List is
    when List = cons H empty then (as text H) .. "]".
    when List = cons H T then (as text H) .. "," .. formatHelper T.
    otherwise then "]".

format list List is "[" .. formatHelper List.

range Low to High is
    when Low > High then empty.
    otherwise then cons Low (range (Low + 1) to High).

range from Low to High is range Low to High.
integers from Low to High is range Low to High.

inc List is
    when List = (cons H T) then
        cons (H + 1) (inc T).
    otherwise then empty.

zip A and B is
    when A = cons HA TA, B = cons HB TB then
        cons (pair HA and HB) (zip TA and TB).
    otherwise then empty.

max of A and B is
    when A > B then A.
    otherwise then B.

min of A and B is
    when A > B then A.
    otherwise then B.

maximum of List is
    when List = cons H empty then H.
    when List = cons H T then max of H and maximum of T.
    otherwise then 0.

minimum of List is
    when List = cons H empty then H.
    when List = cons H T then min of H and minimum of T.
    otherwise then 0.

find factor of N starting with X is
    when X divides N then X.
    otherwise then find factor of N starting with (X + 1).

factors of N is
    when N = 1 then empty.
    otherwise then
        Factor = find factor of N starting with 2,
        cons Factor factors of (N / Factor).

digits of N is
    when N < 10 then cons N empty.
    otherwise then
        N = 10*Rest + Digit,
        Digit >= 0, Digit < 10,
        cons Digit digits of Rest.

palindrome List if reverse list List = List.
palindromic number N if palindrome digits of N.

pair X with each List is
    when List = cons H T then cons (pair X and H) (pair X with each T).
    otherwise then empty.

cartesian product of A and B is
    when A = cons H T then
        concat (pair H with each B) with cartesian product of T and B.
    otherwise then empty.

pairs of A and B is cartesian product of A and B.

take N from List is
    when N > 0, List = cons H T then cons H (take (N - 1) from T).
    otherwise then empty.

drop N from List is
    when N > 0, List = cons H T then drop (N - 1) from T.
    otherwise then List.

product of List is
    when List = cons H T then H * (product of T).
    otherwise then 1.

element N of List starting with H is
    when N <= 0 then H.
    when List = cons X Rest then element (N - 1) of Rest starting with X.
    otherwise then H.

chunks of size L in List is
    when List = empty then empty.
    otherwise then cons (take L from List) (chunks of size L in drop L from List).

chunks of length L in List is chunks of size L in List.

List contains Element if
    when List = cons H T, H = Element then 1 = 1.
    when List = cons H T then T contains Element.
    otherwise then 1 = 2.

remove Element from List is
    when List = cons H T, H = Element then T.
    when List = cons H T then cons H (remove Element from T).
    otherwise then 1 = 2, empty.

mapping K V may be X |-> Y has X : K, Y : V.

X maps to Y is X |-> Y.

maybe A may be
    nothing.
    just X has X : A.

ordering may be
    equal.
    greater.
    less.

compare A to B is
    when A > B then greater.
    when A < B then less.
    otherwise then equal.

key in (K maps to V) is K.
value in (K maps to V) is V.

compare keys (K1 |-> V1) to (K2 |-> V2) is compare K1 to K2.
compare values (K1 |-> V1) to (K2 |-> V2) is compare V1 to V2.

get key Key from Map is
    Map contains (Key |-> V),
    V.

insert K V into Map is cons (K |-> V) Map.

remove key Key from Map is remove (Key |-> V) from Map.

increment key Key in Map is insert Key (V + 1) into (remove (Key |-> V) from Map).

max key at least M1 in Map is
    when Map = cons M2 Assocs, compare keys M2 to M1 = less then max key at least M2 in Assocs.
    when Map = cons P Assocs then max key at least M1 in Assocs.
    otherwise then M1.

max key in Map is
    when Map = cons M1 Assocs then just (max key at least M1 in Map).
    otherwise then nothing.

min key no more than M1 in Map is
    when Map = cons M2 Assocs, compare keys M2 to M1 = less then min key no more than M2 in Assocs.
    when Map = cons P Assocs then min key no more than M1 in Assocs.
    otherwise then M1.

min key in Map is
    when Map = cons M1 Assocs then just (min key no more than M1 in Map).
    otherwise then nothing.

max value at least M1 in Map is
    when Map = cons M2 Assocs, compare values M2 to M1 = less then max value at least M2 in Assocs.
    when Map = cons P Assocs then max value at least M1 in Assocs.
    otherwise then M1.

max value in Map is
    when Map = cons M1 Assocs then just (max value at least M1 in Map).
    otherwise then nothing.

min value no more than M1 in Map is
    when Map = cons M2 Assocs, compare values M2 to M1 = less then min value no more than M2 in Assocs.
    when Map = cons P Assocs then min value no more than M1 in Assocs.
    otherwise then M1.

min value in Map is
    when Map = cons M1 Assocs then just (min value no more than M1 in Map).
    otherwise then nothing.

singleton list X is cons X empty.

init List is
    when List = cons H empty then empty.
    when List = cons H T then cons H (init T).
    otherwise then empty.

last List is
    when List = cons H empty then just H.
    when List = cons H T then last T.
    otherwise then nothing.

List does not contain Element if
    when List = cons Element T then 1 = 2.
    when List = cons H T, H != Element then T does not contain Element.
    otherwise then 1 = 1.

digit from Str is
    when Str = "0" .. Rest then pair 0 and Rest.
    when Str = "1" .. Rest then pair 1 and Rest.
    when Str = "2" .. Rest then pair 2 and Rest.
    when Str = "3" .. Rest then pair 3 and Rest.
    when Str = "4" .. Rest then pair 4 and Rest.
    when Str = "5" .. Rest then pair 5 and Rest.
    when Str = "6" .. Rest then pair 6 and Rest.
    when Str = "7" .. Rest then pair 7 and Rest.
    when Str = "8" .. Rest then pair 8 and Rest.
    when Str = "9" .. Rest then pair 9 and Rest.
    otherwise then pair (-1) and Rest.

digits from Str is
    pair D and Rest = digit from Str,
    when D = -1 then empty.
    otherwise then
        prepend D to digits from Rest.

A mod B is
    A = Q*B + R,
    0 <= R, R < B,
    R.

X to reversed digits is
    when X < 10 then singleton list X.
    otherwise then prepend (X mod 10) to (X / 10) to reversed digits.

X to digits is reverse list X to reversed digits.

from reversed digit list List is
    when List = cons H T then 10 * from reversed digit list T + H.
    otherwise then 0.

from digit list List is
    from reversed digit list (reverse list List).

int from Str is from digit list (digits from Str).

first letter of Text is
    Text = Letter .. Rest,
    number of characters in Letter = 1,
    Letter.

characters of Text is
    when Text = "" then empty.
    otherwise then
        Text = Letter .. Rest,
        number of characters in Letter = 1,
        prepend Letter to characters of Rest.

text from characters in Cs is
    when Cs = cons C Rest then C .. text from characters in Rest.
    otherwise then "".

replace X with Y in A is
    when A != X then A.
    otherwise then Y.

text replace X with Y in T is
    text from characters in map (replace X with Y in _) over characters of T.

