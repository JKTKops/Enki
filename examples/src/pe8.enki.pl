#!/usr/bin/env swipl

:- use_module(library(clpfd)).

:- style_check(-singleton).
:- style_check(-no_effect).
:- style_check(-var_branches).
:- style_check(-discontiguous).
:- style_check(-charset).

:- initialization(main, main).

main(Args) :-
    N = 7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450,
    digits_of(N,Temp13),
    overlapping_chunks_of_size_in(13,Temp13,Temp9),
    products_in(Temp9,Temp7),
    maximum_of(Temp7,Temp5),
    writeln(Temp5).



odd(X) :-
    Temp3 #= 2 * K,
    Temp2 #= Temp3 + 1,
    X = Temp2.

even(X) :-
    Temp2 #= 2 * K,
    X = Temp2.

square_root(X,Root) :-
    Temp1 #= Root ^ 2,
    Temp1 = X.

divides(A,B) :-
    Temp2 #= A * N,
    B = Temp2.

length_of(List,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    List = cons(H,T) -> 
    length_of(T,Temp13),
    Temp11 #= 1 + Temp13,
    AUTOGENERATEDFUNCTIONRESULT = Temp11
    );
    (
    AUTOGENERATEDFUNCTIONRESULT = 0
    ).

construct(Head,Full,Tail) :-
    Full = cons(Head,Tail).

concat(A,B,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    A = cons(H,T) -> 
    concat(T,B,Temp15),
    AUTOGENERATEDFUNCTIONRESULT = cons(H,Temp15)
    );
    (
    AUTOGENERATEDFUNCTIONRESULT = B
    ).

concat_with(A,B,Temp0) :-
    concat(A,B,Temp0).

flatten(List,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    List = cons(H,T) -> 
    flatten(T,Temp15),
    concat_with(H,Temp15,Temp11),
    AUTOGENERATEDFUNCTIONRESULT = Temp11
    );
    (
    AUTOGENERATEDFUNCTIONRESULT = empty
    ).

reverseAcc(A,Acc,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    A = cons(H,T) -> 
    reverseAcc(T,cons(H,Acc),Temp11),
    AUTOGENERATEDFUNCTIONRESULT = Temp11
    );
    (
    AUTOGENERATEDFUNCTIONRESULT = Acc
    ).

reverse_list(A,Temp0) :-
    reverseAcc(A,empty,Temp0).

sum(List,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    List = cons(H,T) -> 
    sum(T,Temp13),
    Temp11 #= H + Temp13,
    AUTOGENERATEDFUNCTIONRESULT = Temp11
    );
    (
    AUTOGENERATEDFUNCTIONRESULT = 0
    ).

sums_to(List,N) :-
    sum(List,Temp2),
    N = Temp2.

sum_of(List,Temp0) :-
    sum(List,Temp0).

multiples_of_in(A,List,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    List = cons(H,T),
    divides(A,H) -> 
    multiples_of_in(A,T,Temp21),
    AUTOGENERATEDFUNCTIONRESULT = cons(H,Temp21)
    );
    (
    List = cons(H,T) -> 
    multiples_of_in(A,T,Temp41),
    AUTOGENERATEDFUNCTIONRESULT = Temp41
    );
    (
    AUTOGENERATEDFUNCTIONRESULT = empty
    ).

formatHelper(List,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    List = cons(H,empty) -> 
    atom_concat(H,"]",Temp11),
    AUTOGENERATEDFUNCTIONRESULT = Temp11
    );
    (
    List = cons(H,T) -> 
    atom_concat(H,",",Temp27),
    formatHelper(T,Temp31),
    atom_concat(Temp27,Temp31,Temp26),
    AUTOGENERATEDFUNCTIONRESULT = Temp26
    );
    (
    AUTOGENERATEDFUNCTIONRESULT = "]"
    ).

format_list(List,Temp0) :-
    formatHelper(List,Temp2),
    atom_concat("[",Temp2,Temp0).

range_to(Low,High,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    Low #> High -> 
    AUTOGENERATEDFUNCTIONRESULT = empty
    );
    (
    Temp16 #= Low + 1,
    range_to(Temp16,High,Temp14),
    AUTOGENERATEDFUNCTIONRESULT = cons(Low,Temp14)
    ).

range_from_to(Low,High,Temp0) :-
    range_to(Low,High,Temp0).

integers_from_to(Low,High,Temp0) :-
    range_to(Low,High,Temp0).

inc(List,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    List = cons(H,T) -> 
    Temp13 #= H + 1,
    inc(T,Temp18),
    AUTOGENERATEDFUNCTIONRESULT = cons(Temp13,Temp18)
    );
    (
    AUTOGENERATEDFUNCTIONRESULT = empty
    ).

zip_and(A,B,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    A = cons(HA,TA),
    B = cons(HB,TB) -> 
    zip_and(TA,TB,Temp30),
    AUTOGENERATEDFUNCTIONRESULT = cons(pair_and(HA,HB),Temp30)
    );
    (
    AUTOGENERATEDFUNCTIONRESULT = empty
    ).

max_of_and(A,B,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    A #> B -> 
    AUTOGENERATEDFUNCTIONRESULT = A
    );
    (
    AUTOGENERATEDFUNCTIONRESULT = B
    ).

min_of_and(A,B,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    A #> B -> 
    AUTOGENERATEDFUNCTIONRESULT = A
    );
    (
    AUTOGENERATEDFUNCTIONRESULT = B
    ).

maximum_of(List,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    List = cons(H,empty) -> 
    AUTOGENERATEDFUNCTIONRESULT = H
    );
    (
    List = cons(H,T) -> 
    maximum_of(T,Temp27),
    max_of_and(H,Temp27,Temp23),
    AUTOGENERATEDFUNCTIONRESULT = Temp23
    );
    (
    AUTOGENERATEDFUNCTIONRESULT = 0
    ).

minimum_of(List,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    List = cons(H,empty) -> 
    AUTOGENERATEDFUNCTIONRESULT = H
    );
    (
    List = cons(H,T) -> 
    minimum_of(T,Temp27),
    min_of_and(H,Temp27,Temp23),
    AUTOGENERATEDFUNCTIONRESULT = Temp23
    );
    (
    AUTOGENERATEDFUNCTIONRESULT = 0
    ).

find_factor_of_starting_with(N,X,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    divides(X,N) -> 
    AUTOGENERATEDFUNCTIONRESULT = X
    );
    (
    Temp15 #= X + 1,
    find_factor_of_starting_with(N,Temp15,Temp11),
    AUTOGENERATEDFUNCTIONRESULT = Temp11
    ).

factors_of(N,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    N = 1 -> 
    AUTOGENERATEDFUNCTIONRESULT = empty
    );
    (
    find_factor_of_starting_with(N,2,Temp10),
    Factor = Temp10,
    Temp25 #= N div Factor,
    factors_of(Temp25,Temp23),
    AUTOGENERATEDFUNCTIONRESULT = cons(Factor,Temp23)
    ).

digits_of(N,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    N #< 10 -> 
    AUTOGENERATEDFUNCTIONRESULT = cons(N,empty)
    );
    (
    Temp15 #= 10 * Rest,
    Temp14 #= Temp15 + Digit,
    N = Temp14,
    Digit #>= 0,
    Digit #< 10,
    digits_of(Rest,Temp33),
    AUTOGENERATEDFUNCTIONRESULT = cons(Digit,Temp33)
    ).

palindrome(List) :-
    reverse_list(List,Temp1),
    Temp1 = List.

palindrome_number(N) :-
    digits_of(N,Temp2),
    palindrome(Temp2).

pair_with_each(X,List,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    List = cons(H,T) -> 
    pair_with_each(X,T,Temp21),
    AUTOGENERATEDFUNCTIONRESULT = cons(pair_and(X,H),Temp21)
    );
    (
    AUTOGENERATEDFUNCTIONRESULT = empty
    ).

cartesian_product_of_and(A,B,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    A = cons(H,T) -> 
    pair_with_each(H,B,Temp13),
    cartesian_product_of_and(T,B,Temp21),
    concat_with(Temp13,Temp21,Temp11),
    AUTOGENERATEDFUNCTIONRESULT = Temp11
    );
    (
    AUTOGENERATEDFUNCTIONRESULT = empty
    ).

pairs_of_and(A,B,Temp0) :-
    cartesian_product_of_and(A,B,Temp0).

take_from(N,List,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    N #> 0,
    List = cons(H,T) -> 
    Temp20 #= N - 1,
    take_from(Temp20,T,Temp18),
    AUTOGENERATEDFUNCTIONRESULT = cons(H,Temp18)
    );
    (
    AUTOGENERATEDFUNCTIONRESULT = empty
    ).

drop_from(N,List,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    N #> 0,
    List = cons(H,T) -> 
    Temp16 #= N - 1,
    drop_from(Temp16,T,Temp14),
    AUTOGENERATEDFUNCTIONRESULT = Temp14
    );
    (
    AUTOGENERATEDFUNCTIONRESULT = List
    ).

product(List,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    List = cons(H,T) -> 
    product(T,Temp13),
    Temp11 #= H * Temp13,
    AUTOGENERATEDFUNCTIONRESULT = Temp11
    );
    (
    AUTOGENERATEDFUNCTIONRESULT = 1
    ).

product_of(List,Temp0) :-
    product(List,Temp0).

element_of(N,List,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    N #=< 0,
    List = cons(H,T) -> 
    AUTOGENERATEDFUNCTIONRESULT = H
    );
    (
    N #> 0,
    List = cons(H,T),
    Temp31 #= N - 1,
    element_of(Temp31,T,Temp29),
    AUTOGENERATEDFUNCTIONRESULT = Temp29
    ).

chunks_of_size_in(L,List,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    List = empty -> 
    AUTOGENERATEDFUNCTIONRESULT = empty
    );
    (
    take_from(L,List,Temp14),
    drop_from(L,List,Temp26),
    chunks_of_size_in(L,Temp26,Temp22),
    AUTOGENERATEDFUNCTIONRESULT = cons(Temp14,Temp22)
    ).

chunks_of_length_in(L,List,Temp0) :-
    chunks_of_size_in(L,List,Temp0).

prepend_to(Head,Tail,cons(Head,Tail)).

overlapping_chunks_of_size_in(L,List,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    List = empty -> 
    AUTOGENERATEDFUNCTIONRESULT = empty
    );
    (
    take_from(L,List,Temp14),
    drop_from(1,List,Temp26),
    overlapping_chunks_of_size_in(L,Temp26,Temp22),
    prepend_to(Temp14,Temp22,Temp12),
    AUTOGENERATEDFUNCTIONRESULT = Temp12
    ).

products_in(List,AUTOGENERATEDFUNCTIONRESULT) :-
    (
    prepend_to(H,T,Temp2),
    List = Temp2 -> 
    product_of(H,Temp13),
    products_in(T,Temp19),
    prepend_to(Temp13,Temp19,Temp11),
    AUTOGENERATEDFUNCTIONRESULT = Temp11
    );
    (
    AUTOGENERATEDFUNCTIONRESULT = empty
    ).


