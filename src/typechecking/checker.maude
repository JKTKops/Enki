mod ENKI-TYPECHECK is
    protecting ENKI-SYNTAX-SORTS .
    protecting ENKI-SYNTAX-UTILITY .
    protecting ENKI-TYPECHECK-SORTS .
    protecting ENKI-UNIFICATION .
    protecting ENKI-TYPECHECK-ENV .
    protecting ENKI-TYPECHECK-BUILTINS .

    protecting LIST{EnkiFunc} .
    protecting LIST{EnkiDef} .
    protecting LIST{TypedDef} .
    protecting LIST{TypedFunc} .
    protecting LIST{TypedConstraint} .

    protecting SET{EnkiType} .

    protecting CONVERSION .

    vars S S1 S2 : String .
    var I : Int .
    var B : Bool .
    vars Id Id1 Id2 : Id .
    var Ids : List{Id} .

    vars T T1 T2 : EnkiType .
    vars TID TID1 TID2 : TypedId .
    vars TIDS TIDS1 TIDS2 : Set{TypedId} .
    var L : List{TypedId} .
    var Types : List{EnkiType} .
    var Strs : List{String} .

    var Ts : Set{EnkiType} .

    var RestTIDS : Set{TypedId} .
    var FuncId : Id .

    var NewTIDS : Set{TypedId} .
    var Funcs : List{EnkiFunc} .
    var TFunc : TypedFunc .
    var TExpr : TypedExpr .

    op attachType : Set{TypedId} Id -> TypedId .
    eq attachType(TIDS, Id) = tid(Id, typeof(TIDS, Id)) .

    op attachVars : Set{TypedId} List{Id} -> List{TypedId} .
    eq attachVars(TIDS, nil)                    = nil .
    ceq attachVars(TIDS, (Id Ids)) = tid(Id, T) attachVars((tid(Id, T), TIDS), Ids)
        if T := typeof(TIDS, Id) .

    op attachConstraintTypes : Set{TypedId} Constraint -> List{TypedConstraint} .
    eq attachConstraintTypes((tid(Id, T), TIDS), c(Id)) = typedConstraint(tid(Id, T)) .
    eq attachConstraintTypes(TIDS, cs(nil)) = typedConstraints(nil) .
    ceq attachConstraintTypes(TIDS, when(C1, C2)) = typedWhen(TConstraint1, TConstraint2)
        if TConstraint1 := flatten(typedConstraints(attachConstraintTypes(TIDS, C1))) /\
           TConstraint2 := flatten(typedConstraints(attachConstraintTypes(TIDS, C2))) .
    eq attachConstraintTypes(TIDS, cs(C Cs)) = attachConstraintTypes(TIDS, C) attachConstraintTypes(TIDS, cs(Cs)) .

    op functype : NeList{TypedId} -> EnkiType .
    eq functype(tid(Id, T))   = T .
    eq functype(tid(Id, T) L) = func(T, functype(L)) .

    op ruletype : NeList{TypedId} -> EnkiType .
    eq ruletype(tid(Id, T))   = T .
    eq ruletype(tid(Id, T) L) = rule(T, ruletype(L)) .

    op datatype : NeList{TypedId} -> EnkiType .
    eq datatype(tid(Id, T))   = T .
    eq datatype(tid(Id, T) L) = data(T, datatype(L)) .

    op funcTypeList : EnkiType -> List{EnkiType} .
    eq funcTypeList(func(T1, T2)) = T1 funcTypeList(T2) .
    eq funcTypeList(data(T1, T2)) = T1 funcTypeList(T2) .
    eq funcTypeList(rule(T1, T2)) = T1 funcTypeList(T2) .
    eq funcTypeList(T)            = T [owise] .

    op unifyMap : Set{TypedId} List{EnkiType} List{String} Map{String, Id} -> Set{TypedId} .
    eq unifyMap(TIDS, Types, nil, VarMap) = TIDS .
    eq unifyMap(TIDS, T Types, S Strs, (S |-> Id, VarMap)) = unifyMap(inferId(unifyType(TIDS, Id, T), Id), Types, Strs, VarMap) .

    vars Ids1 Ids2 : List{Id} .
    op funcNameMatches : Id Id -> Bool .
    eq funcNameMatches(v(S), Id) = true .
    eq funcNameMatches(s(S), s(S)) = true .
    eq funcNameMatches(comp(nil), comp(nil)) = true .
    eq funcNameMatches(comp(Id1 Ids1), comp(Id2 Ids2)) = funcNameMatches(Id1, Id2) and funcNameMatches(comp(Ids1), comp(Ids2)) .

    --- Take the function id (first) and the id to unify it with (second)
    --- Returns a map from the variables in the function id to idenitifiers in the second id
    --- NOTE: Be sure to call funcNameMatches too, to make sure this function won't get stuck!
    op funcUnify : Id Id -> Map{String, Id} .
    eq funcUnify(v(S), Id) = S |-> Id .
    eq funcUnify(s(S), s(S)) = empty .
    eq funcUnify(comp(nil), comp(nil)) = empty .
    eq funcUnify(comp(Id1 Ids1), comp(Id2 Ids2)) = funcUnify(Id1, Id2), funcUnify(comp(Ids1), comp(Ids2)) .

    --- Return the typed id of the function matching the Id passed in, if any matches
    op findFuncType : Set{TypedId} Id -> TypedId .
    ceq findFuncType((tid(fid(Id1), T), TIDS), Id2) = tid(Id1, T)
        if funcNameMatches(Id1, Id2) .

    --- TODO: Weird that we need to unify again at the end for the first case (equality)--unifyAll should take care of this for us?
    --- TODO: handle builtins better
    var FuncType : EnkiType .
    op inferId : Set{TypedId} Id -> Set{TypedId} .
    ceq inferId(TIDS, Id) = unify(inferId(inferId(unify(unify(TIDS, Id1, Id2), Id, Id1), Id1), Id2), Id1, Id2)
        if comp(Id1 s("=") Id2) := Id .
    ceq inferId(TIDS, Id) = inferId(inferId(unify(unify(unifyType(TIDS, Id1, int), Id2, Id1), Id, Id1), Id1), Id2)
        if comp(Id1 s(S) Id2) := Id /\
           (isArith(S) or isIntComp(S)) .
    ceq inferId(TIDS, Id) = inferId(inferId(unify(unify(unifyType(TIDS, Id1, string), Id1, Id2), Id, Id1), Id1), Id2)
        if comp(Id1 s(S) Id2) := Id /\
           isStrOp(S) .
    ceq inferId(TIDS, Id) = unifyType(unifyMap(TIDS, Types, varstrs(FuncId), VarMap), Id, T)
        if tid(FuncId, FuncType) := findFuncType(builtinsIds, Id) /\
           T                     := returnType(FuncType)   /\
           Types                 := funcTypeList(FuncType) /\
           VarMap                := funcUnify(FuncId, Id) .
    ceq inferId(TIDS, Id) = unifyType(unifyMap(TIDS, Types, varstrs(FuncId), VarMap), Id, T)
        if tid(FuncId, FuncType) := findFuncType(TIDS, Id) /\
           T                     := returnType(FuncType)   /\
           Types                 := funcTypeList(FuncType) /\
           VarMap                := funcUnify(FuncId, Id) .
    eq inferId(TIDS, Id) = TIDS [owise] .

    vars C C1 C2 : Constraint .
    var Cs : List{Constraint} .
    op inferConstraint : Set{TypedId} Constraint -> Set{TypedId} .
    eq inferConstraint(TIDS, c(Id))    = inferId(TIDS, Id) .
    eq inferConstraint(TIDS, when(C1, C2)) = inferConstraint(inferConstraint(TIDS, C1), C2) .
    eq inferConstraint(TIDS, cs(nil))  = TIDS .
    eq inferConstraint(TIDS, cs(C Cs)) = inferConstraint(inferConstraint(TIDS, C), cs(Cs)) .

    op makeFuncType : Set{TypedId} Id Id -> EnkiType .
    eq makeFuncType(TIDS, Id1, Id2) = functype(attachVars(TIDS, varlist(Id1)) attachType(TIDS, Id2)) .

    op makeRuleType : Set{TypedId} Id -> EnkiType .
    eq makeRuleType(TIDS, RuleId) = ruletype(attachVars(TIDS, varlist(RuleId))) .

    var VarMap : Map{String, Id} .

    var DummyT : EnkiType .
    var ResolvedId : Id .

    op resolveMap : Set{TypedId} Map{String, Id} -> Map{String, Id} .
    eq resolveMap(TIDS, empty) = empty .
    ceq resolveMap(TIDS, (S |-> Id, VarMap)) = (S |-> ResolvedId, resolveMap(TIDS, VarMap))
        if DummyT := firstUnused(types(TIDS), 0) /\
           tid(ResolvedId, DummyT) := resolve(TIDS, tid(Id, DummyT)) .

    var BuiltInSet : Set{Builtin} .

    op resolve : Set{TypedId} TypedId -> TypedId .
    eq resolve(TIDS,  tid(v(S), T))     = tid(v(S), T) .
    eq resolve(TIDS,  tid(b(B), T))     = tid(b(B), T) .
    eq resolve(TIDS,  tid(i(I), T))     = tid(i(I), T) .
    eq resolve(TIDS,  tid(s(S), T))     = tid(s(S), T) .
    ceq resolve(TIDS, tid(t(Id, T), T)) = tid(t(Id1, T), T)
        if tid(Id1, T1) := resolve(TIDS, tid(Id, T)) .
    eq resolve(TIDS,  tid(comp(nil), T)) = tid(comp(nil), T) .
    --- Check if this is some builtin, and look it up, if so
    ceq resolve(TIDS, tid(Id, T1)) = tid(fcall(ResolvedId, T, resolveMap(TIDS, VarMap)), T1)
        if (tid(fid(FuncId), T), RestTIDS) := builtinsIds /\
           VarMap                          := funcUnify(FuncId, Id) /\
           funcNameMatches(FuncId, Id) /\
           (builtin(FuncId, ResolvedId), BuiltInSet)  := builtinsNames .
    --- Lookup the function call, if applicable
    ceq resolve(TIDS, tid(comp(Ids), T1)) = tid(fcall(FuncId, T, resolveMap(TIDS, VarMap)), T1)
        if (tid(fid(FuncId), T), RestTIDS) := TIDS /\
           VarMap                          := funcUnify(FuncId, comp(Ids)) /\
           funcNameMatches(FuncId, comp(Ids)) .
    --- Otherwise, resolve each in sequence (important for things like "X + Y")
    ceq resolve(TIDS, tid(comp(Id Ids), T1)) = tid(prependIds(Id1, Id2), T1)
        --- Generate a new dummy types (if necessary)
        if DummyT := firstUnused(types(TIDS), 0) /\
           tid(Id1, DummyT) := resolve(TIDS, tid(Id, DummyT)) /\
           tid(Id2, DummyT) := resolve(TIDS, tid(comp(Ids), DummyT)) .

    var TConstraint : TypedConstraint .
    var TConstraints : List{TypedConstraint} .
    vars TCs1 TCs2 : List{TypedConstraint} .

    op combine : TypedConstraint TypedConstraint -> TypedConstraint .
    eq combine(typedConstraints(nil), TConstraint) = TConstraint .
    eq combine(TConstraint, typedConstraints(nil)) = TConstraint .
    eq combine(typedConstraints(TCs1), typedConstraints(TCs2)) = typedConstraints(append(TCs1, TCs2)) .
    eq combine(TConstraint1, TConstraint2) = typedConstraints(TConstraint1 TConstraint2) [owise] .

    op flatten : TypedConstraint -> TypedConstraint .
    eq flatten(typedConstraint(TID)) = typedConstraint(TID) .
    eq flatten(typedConstraints(nil)) = typedConstraints(nil) .
    eq flatten(typedWhen(TConstraint1, TConstraint2)) = typedWhen(flatten(TConstraint1), flatten(TConstraint2)) .
    eq flatten(typedConstraints(TConstraint)) = flatten(TConstraint) .
    eq flatten(typedConstraints(TConstraint TConstraints)) =
        combine(flatten(TConstraint), flatten(typedConstraints(TConstraints))) .

    vars TConstraint1 TConstraint2 : TypedConstraint .
    op resolveConstraints : Set{TypedId} List{TypedConstraint} -> TypedConstraint .
    eq resolveConstraints(TIDS, nil) = typedConstraints(nil) .
    eq resolveConstraints(TIDS, typedConstraints(nil)) = typedConstraints(nil) .
    eq resolveConstraints(TIDS, typedConstraints(TConstraint TConstraints)) =
        resolveConstraints(TIDS, TConstraint TConstraints) .
    eq resolveConstraints(TIDS, nil) = typedConstraint(nil) .
    eq resolveConstraints(TIDS, typedWhen(TConstraint1, TConstraint2) TConstraints) =
        flatten(typedConstraints(typedWhen(resolveConstraints(TIDS, TConstraint1), resolveConstraints(TIDS, TConstraint2)) resolveConstraints(TIDS, TConstraints))).
    eq resolveConstraints(TIDS, typedConstraint(TID) TConstraints) =
        flatten(typedConstraints(typedConstraint(resolve(TIDS, TID)) resolveConstraints(TIDS, TConstraints))) .

    var Constraint : Constraint .
    var FinalTIDS : Set{TypedId} .
    op inferFunc : Set{TypedId} EnkiFunc -> TypedFunc .
    ceq inferFunc(TIDS, f(Id1, Constraint, e(Id2))) = typed(Id1, FuncType, TConstraint, TExpr)
        if Ids         := append(idList(Id1), append(idList(Id2), constraintIds(Constraint))) /\
           NewTIDS     := inferConstraint(inferId(freshtypes(TIDS, Ids), Id2), Constraint) /\
           FuncType    := makeFuncType(NewTIDS, Id1, Id2) /\
           FinalTIDS   := unifyType(NewTIDS, fid(Id1), FuncType) /\
           TExpr       := typedExpr(resolve(FinalTIDS, attachType(NewTIDS, Id2))) /\
           TConstraint := resolveConstraints(FinalTIDS, attachConstraintTypes(NewTIDS, Constraint)) .

    var RuleId : Id .
    var RuleType : EnkiType .
    op inferRule : Set{TypedId} EnkiRule -> TypedRule .
    ceq inferRule(TIDS, r(RuleId, Constraint)) = typed(RuleId, RuleType, TConstraint)
        if Ids  := append(idList(RuleId), constraintIds(Constraint)) /\
           NewTIDS     := inferConstraint(freshtypes(TIDS, Ids), Constraint) /\
           RuleType    := makeRuleType(NewTIDS, RuleId) /\
           FinalTIDS   := unifyType(NewTIDS, fid(RuleId), RuleType) /\
           TConstraint := resolveConstraints(FinalTIDS, attachConstraintTypes(FinalTIDS, Constraint)) .

    var Defs : List{EnkiDef} .
    var Func : EnkiFunc .
    var Rule : EnkiRule .
    var TRule : TypedRule .

    --- These exist to allow functions/rules to call themselves
    --- It just provides a dummy type that has no type information, it just serves to say the definition exists.
    op dummyFuncType : Set{TypedId} Id -> Set{TypedId} .
    ceq dummyFuncType(TIDS, Id) = (tid(fid(Id), FuncType), TIDS)
        if NewTIDS  := freshtypes(TIDS, varlist(Id)) /\
           any(S)   := firstUnused(types(NewTIDS), 0) /\
           FuncType := functype(attachVars((tid(v(S), any(S)), NewTIDS), varlist(Id)) tid(v(S), any(S))) .

    op dummyRuleType : Set{TypedId} Id -> Set{TypedId} .
    ceq dummyRuleType(TIDS, Id) = (tid(fid(Id), FuncType), TIDS)
        if NewTIDS  := freshtypes(TIDS, varlist(Id)) /\
           FuncType := ruletype(attachVars(TIDS, varlist(Id))) .

    var Constructor : Constructor .
    var Constructors : List{Constructor} .
    var Field : Field .
    var Fields : List{Field} .

    op fieldTypes : List{Field} -> List{TypedId} .
    eq fieldTypes(nil) = nil .
    eq fieldTypes(field(Id, T) Fields) = tid(Id, T) fieldTypes(Fields) .

    var TypeId : Id .
    op constructorType : Id Constructor -> TypedId .
    eq constructorType(TypeId, constructor(Id, Fields)) = tid(fid(Id), datatype(fieldTypes(Fields) tid(TypeId, type(TypeId)))) .

    op constructorTypes : Id List{Constructor} -> Set{TypedId} .
    eq constructorTypes(Id, nil) = empty .
    eq constructorTypes(Id, Constructor Constructors) = constructorType(Id, Constructor), constructorTypes(Id, Constructors) .

    var Expr : Expr .
    var MoreDefs : List{EnkiDef} .

    op inferDefs : Set{TypedId} List{EnkiDef} -> List{TypedDef} .
    eq inferDefs(TIDS, nil) = nil .
    eq inferDefs(TIDS, import(m(MoreDefs)) Defs) = inferDefs(TIDS, append(MoreDefs, Defs)) .
    ceq inferDefs(TIDS, exec(ex(Constraint)) Defs) = exec(typedExec(TConstraint)) inferDefs(TIDS, Defs)
        if NewTIDS     := inferConstraint(freshtypes(TIDS, constraintIds(Constraint)), Constraint) /\
           TConstraint := resolveConstraints(NewTIDS, attachConstraintTypes(NewTIDS, Constraint)).
    ceq inferDefs(TIDS, def(Func) Defs) = def(TFunc) inferDefs((tid(fid(Id), T), TIDS), Defs)
        if f(FuncId, C, Expr)               := Func /\
           TFunc                            := inferFunc(dummyFuncType(TIDS, FuncId), Func) /\
           typed(Id, T, TConstraint, TExpr) := TFunc .
    ceq inferDefs(TIDS, def(Rule) Defs) = def(TRule) inferDefs((tid(fid(Id), T), TIDS), Defs)
        if r(RuleId, C)              := Rule /\
           TRule                     := inferRule(dummyRuleType(TIDS, RuleId), Rule) /\
           typed(Id, T, TConstraint) := TRule .
    ceq inferDefs(TIDS, def(d(Id, Constructors)) Defs) = inferDefs((NewTIDS, TIDS), Defs)
        if NewTIDS := constructorTypes(Id, Constructors) .
endm

