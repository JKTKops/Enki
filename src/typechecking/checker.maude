mod ENKI-TYPECHECK is
    protecting ENKI-SYNTAX-SORTS .
    protecting ENKI-SYNTAX-UTILITY .
    protecting ENKI-TYPECHECK-SORTS .
    protecting ENKI-UNIFICATION .
    protecting ENKI-TYPECHECK-ENV .

    protecting LIST{EnkiFunc} .
    protecting LIST{EnkiDef} .
    protecting LIST{TypedDef} .
    protecting LIST{TypedFunc} .
    protecting LIST{TypedConstraint} .

    protecting SET{EnkiType} .

    protecting CONVERSION .

    vars S S1 S2 : String .
    var I : Int .
    var B : Bool .
    vars Id Id1 Id2 : Id .
    var Ids : List{Id} .

    vars T T1 T2 : EnkiType .
    vars TID TID1 TID2 : TypedId .
    vars TIDS TIDS1 TIDS2 : Set{TypedId} .
    var L : List{TypedId} .
    var Types : List{EnkiType} .
    var Strs : List{String} .

    var Ts : Set{EnkiType} .

    var RestTIDS : Set{TypedId} .
    var FuncId : Id .

    var NewTIDS : Set{TypedId} .
    var Funcs : List{EnkiFunc} .
    var TFunc : TypedFunc .
    var TExpr : TypedExpr .

    op attachType : Set{TypedId} Id -> TypedId .
    eq attachType(TIDS, Id) = tid(Id, typeof(TIDS, Id)) .

    op attachVars : Set{TypedId} List{Id} -> List{TypedId} .
    eq attachVars(TIDS, nil)                    = nil .
    ceq attachVars(TIDS, (Id Ids)) = tid(Id, T) attachVars((tid(Id, T), TIDS), Ids)
        if T := typeof(TIDS, Id) .

    op attachConstraintTypes : Set{TypedId} Constraint -> List{TypedConstraint} .
    eq attachConstraintTypes((tid(Id, T), TIDS), c(Id)) = typedConstraint(tid(Id, T)) .
    eq attachConstraintTypes(TIDS, cs(nil)) = typedConstraints(nil) .
    eq attachConstraintTypes(TIDS, cs(C Cs)) = attachConstraintTypes(TIDS, C) attachConstraintTypes(TIDS, cs(Cs)) .

    op functype : NeList{TypedId} -> EnkiType .
    eq functype(tid(Id, T))   = T .
    eq functype(tid(Id, T) L) = func(T, functype(L)) .

    op unifyMap : Set{TypedId} List{EnkiType} List{String} Map{String, Id} -> Set{TypedId} .
    eq unifyMap(TIDS, Types, nil, VarMap) = TIDS .
    eq unifyMap(TIDS, T Types, S Strs, (S |-> Id, VarMap)) = unifyMap(inferId(unifyType(TIDS, Id, T), Id), Types, Strs, VarMap) .

    op funcTypeList : EnkiType -> List{EnkiType} .
    eq funcTypeList(func(T1, T2)) = T1 funcTypeList(T2) .
    eq funcTypeList(T)            = T [owise] .

    vars Ids1 Ids2 : List{Id} .
    op funcNameMatches : Id Id -> Bool .
    eq funcNameMatches(v(S), Id) = true .
    eq funcNameMatches(s(S), s(S)) = true .
    eq funcNameMatches(comp(nil), comp(nil)) = true .
    eq funcNameMatches(comp(Id1 Ids1), comp(Id2 Ids2)) = funcNameMatches(Id1, Id2) and funcNameMatches(comp(Ids1), comp(Ids2)) .

    op funcUnify : Id Id -> Map{String, Id} .
    eq funcUnify(v(S), Id) = S |-> Id .
    eq funcUnify(s(S), s(S)) = empty .
    eq funcUnify(comp(nil), comp(nil)) = empty .
    eq funcUnify(comp(Id1 Ids1), comp(Id2 Ids2)) = funcUnify(Id1, Id2), funcUnify(comp(Ids1), comp(Ids2)) .

    op findFuncType : Set{TypedId} Id -> TypedId .
    ceq findFuncType((tid(fid(Id1), T), TIDS), Id2) = tid(Id1, T)
        if funcNameMatches(Id1, Id2) .

    --- TODO: Weird that we need to unify again at the end for the first case (equality)--unifyAll should take care of this for us?
    var FuncType : EnkiType .
    op inferId : Set{TypedId} Id -> Set{TypedId} .
    ceq inferId(TIDS, Id) = unify(inferId(inferId(unify(unify(TIDS, Id1, Id2), Id, Id1), Id1), Id2), Id1, Id2)
        if comp(Id1 s("=") Id2) := Id .
    ceq inferId(TIDS, Id) = inferId(inferId(unify(unify(unifyType(TIDS, Id1, int), Id1, Id2), Id, Id1), Id1), Id2)
        if comp(Id1 s(S) Id2) := Id /\
           isArith(S) .
    ceq inferId(TIDS, Id) = inferId(inferId(unify(unify(unifyType(TIDS, Id1, string), Id1, Id2), Id, Id1), Id1), Id2)
        if comp(Id1 s(S) Id2) := Id /\
           isStrOp(S) .
    ceq inferId(TIDS, Id) = unifyType(unifyMap(TIDS, Types, varstrs(FuncId), VarMap), Id, T)
        if tid(FuncId, FuncType) := findFuncType(TIDS, Id) /\
           Ids                   := varlist(Id)            /\
           T                     := returnType(FuncType)   /\
           Types                 := funcTypeList(FuncType) /\
           VarMap                := funcUnify(FuncId, Id) .
    eq inferId(TIDS, Id) = TIDS [owise] .

    var C : Constraint .
    var Cs : List{Constraint} .
    op inferConstraint : Set{TypedId} Constraint -> Set{TypedId} .
    eq inferConstraint(TIDS, c(Id))    = inferId(TIDS, Id) .
    eq inferConstraint(TIDS, cs(nil))  = TIDS .
    eq inferConstraint(TIDS, cs(C Cs)) = inferConstraint(inferConstraint(TIDS, C), cs(Cs)) .

    op makeFuncType : Set{TypedId} Id Id -> EnkiType .
    eq makeFuncType(TIDS, Id1, Id2) = functype(attachVars(TIDS, varlist(Id1)) attachType(TIDS, Id2)) .

    op makeRuleType : Set{TypedId} Id -> EnkiType .
    eq makeRuleType(TIDS, RuleId) = functype(attachVars(TIDS, varlist(RuleId))) .

    var VarMap : Map{String, Id} .

    var DummyT : EnkiType .
    var ResolvedId : Id .

    op resolveMap : Set{TypedId} Map{String, Id} -> Map{String, Id} .
    eq resolveMap(TIDS, empty) = empty .
    ceq resolveMap(TIDS, (S |-> Id, VarMap)) = (S |-> ResolvedId, resolveMap(TIDS, VarMap))
        if DummyT := firstUnused(types(TIDS), 0) /\
           tid(ResolvedId, DummyT) := resolve(TIDS, tid(Id, DummyT)) .

    op resolve : Set{TypedId} TypedId -> TypedId .
    eq resolve(TIDS,  tid(v(S), T))     = tid(v(S), T) .
    eq resolve(TIDS,  tid(b(B), T))     = tid(b(B), T) .
    eq resolve(TIDS,  tid(i(I), T))     = tid(i(I), T) .
    eq resolve(TIDS,  tid(s(S), T))     = tid(s(S), T) .
    ceq resolve(TIDS, tid(t(Id, T), T)) = tid(t(Id1, T), T)
        if tid(Id1, T1) := resolve(TIDS, tid(Id, T)) .
    eq resolve(TIDS,  tid(comp(nil), T)) = tid(comp(nil), T) .
    --- Lookup the function call, if applicable
    ceq resolve(TIDS, tid(comp(Ids), T1)) = tid(fcall(FuncId, funcTypeList(T), resolveMap(TIDS, VarMap)), T1)
        if (tid(fid(FuncId), T), RestTIDS) := TIDS /\
           VarMap                          := funcUnify(FuncId, comp(Ids)) /\
           funcNameMatches(FuncId, comp(Ids)) .
    --- Otherwise, resolve each in sequence (important for things like "X + Y")
    ceq resolve(TIDS, tid(comp(Id Ids), T1)) = tid(prependIds(Id1, Id2), T1)
        --- Generate a new dummy types (if necessary)
        if DummyT := firstUnused(types(TIDS), 0) /\
           tid(Id1, DummyT) := resolve(TIDS, tid(Id, DummyT)) /\
           tid(Id2, DummyT) := resolve(TIDS, tid(comp(Ids), DummyT)) .

    var TConstraint : TypedConstraint .
    var TConstraints : List{TypedConstraint} .
    vars TCs1 TCs2 : List{TypedConstraint} .

    op combineConstraints : TypedConstraint TypedConstraint -> TypedConstraint .
    eq combineConstraints(typedConstraints(nil), TConstraint) = TConstraint .
    eq combineConstraints(TConstraint, typedConstraints(nil)) = TConstraint .
    eq combineConstraints(typedConstraint(TID1), typedConstraint(TID2)) = typedConstraints(typedConstraint(TID1) typedConstraint(TID2)) .
    eq combineConstraints(typedConstraints(TCs1), typedConstraints(TCs2)) = typedConstraints(append(TCs1, TCs2)) .

    op flattenTConstraint : TypedConstraint -> TypedConstraint .
    eq flattenTConstraint(typedConstraint(TID)) = typedConstraint(TID) .
    eq flattenTConstraint(typedConstraints(nil)) = typedConstraints(nil) .
    eq flattenTConstraint(typedConstraints(TConstraint TConstraints)) =
        combineConstraints(flattenTConstraint(TConstraint), flattenTConstraint(typedConstraints(TConstraints))) .

    op resolveConstraints : Set{TypedId} List{TypedConstraint} -> TypedConstraint .
    eq resolveConstraints(TIDS, typedConstraints(nil)) = typedConstraints(nil) .
    eq resolveConstraints(TIDS, typedConstraints(TConstraint TConstraints)) =
        resolveConstraints(TIDS, TConstraint TConstraints) .
    eq resolveConstraints(TIDS, nil) = typedConstraint(nil) .
    eq resolveConstraints(TIDS, typedConstraint(TID) TConstraints) =
        flattenTConstraint(typedConstraints(typedConstraint(resolve(TIDS, TID)) resolveConstraints(TIDS, TConstraints))) .

    var Constraint : Constraint .
    op inferFunc : Set{TypedId} EnkiFunc -> TypedFunc .
    ceq inferFunc(TIDS, f(Id1, Constraint, e(Id2))) = typed(Id1, makeFuncType(NewTIDS, Id1, Id2), TConstraint, TExpr)
        if Ids         := append(idList(Id1), append(idList(Id2), constraintIds(Constraint))) /\
           NewTIDS     := inferConstraint(inferId(freshtypes(TIDS, Ids), Id2), Constraint) /\
           TExpr       := typedExpr(resolve(TIDS, attachType(NewTIDS, Id2))) /\
           TConstraint := resolveConstraints(TIDS, attachConstraintTypes(NewTIDS, Constraint)) .

    var RuleId : Id .
    op inferRule : Set{TypedId} EnkiRule -> TypedRule .
    ceq inferRule(TIDS, r(RuleId, Constraint)) = typed(RuleId, makeRuleType(NewTIDS, RuleId), TConstraint)
        if Ids  := append(idList(RuleId), constraintIds(Constraint)) /\
           NewTIDS     := inferConstraint(freshtypes(TIDS, Ids), Constraint) /\
           TConstraint := resolveConstraints(TIDS, attachConstraintTypes(NewTIDS, Constraint)) .

    var Defs : List{EnkiDef} .
    var Func : EnkiFunc .
    var Rule : EnkiRule .
    var TRule : TypedRule .

    op inferDefs : Set{TypedId} List{EnkiDef} -> List{TypedDef} .
    eq inferDefs(TIDS, nil) = nil .
    ceq inferDefs(TIDS, def(Func) Defs) = def(TFunc) inferDefs((tid(fid(Id), T), TIDS), Defs)
        if TFunc := inferFunc(TIDS, Func) /\
           typed(Id, T, TConstraint, TExpr) := TFunc .
    ceq inferDefs(TIDS, def(Rule) Defs) = def(TRule) inferDefs((tid(rid(Id), T), TIDS), Defs)
        if TRule := inferRule(TIDS, Rule) /\
           typed(Id, T, TConstraint) := TRule .
endm

