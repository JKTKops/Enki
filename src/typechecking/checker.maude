mod ENKI-TYPECHECK is
    protecting ENKI-SYNTAX-SORTS .
    protecting ENKI-SYNTAX-UTILITY .
    protecting ENKI-TYPECHECK-SORTS .
    protecting ENKI-UNIFICATION .
    protecting ENKI-TYPECHECK-ENV .
    protecting ENKI-TYPECHECK-BUILTINS .
    protecting ENKI-TYPECHECK-FUNC-UNIFY .
    protecting ENKI-TYPECHECK-ERRORS .

    protecting LIST{EnkiFunc} .
    protecting LIST{EnkiDef} .
    protecting LIST{TypedDef} .
    protecting LIST{TypedFunc} .
    protecting LIST{TypedConstraint} .

    protecting SET{EnkiType} .
    protecting SET{Id}.

    protecting CONVERSION .

    vars S S1 S2 : String .
    var I : Int .
    var B : Bool .
    vars Id Id1 Id2 : Id .
    var Ids : List{Id} .

    vars T T1 T2 : EnkiType .
    vars TID TID1 TID2 : TypedId .
    vars TIDS TIDS1 TIDS2 : Set{TypedId} .
    var L : List{TypedId} .
    var Types : List{EnkiType} .
    var Strs : List{String} .

    var Ts : Set{EnkiType} .

    var RestTIDS : Set{TypedId} .
    var FuncId : Id .

    var NewTIDS : Set{TypedId} .
    var Funcs : List{EnkiFunc} .
    var TFunc : TypedFunc .
    var TExpr : TypedExpr .

    op attachType : Set{TypedId} Id -> TypedId .
    eq attachType(TIDS, Id) = tid(Id, typeof(TIDS, Id)) .

    op attachVars : Set{TypedId} List{Id} -> List{TypedId} .
    eq attachVars(TIDS, nil)                    = nil .
    ceq attachVars(TIDS, (Id Ids)) = tid(Id, T) attachVars((tid(Id, T), TIDS), Ids)
        if T := typeof(TIDS, Id) .

    op attachConstraintTypes : Set{TypedId} Constraint -> TypedConstraint .
    eq attachConstraintTypes(TIDS, c(Id)) = typed(attachType(TIDS, Id)) .
    ceq attachConstraintTypes(TIDS, when(C1, C2)) = typedWhen(TConstraint1, TConstraint2)
        if TConstraint1 := attachConstraintTypes(TIDS, C1) /\
           TConstraint2 := attachConstraintTypes(TIDS, C2) .
    eq attachConstraintTypes(TIDS, cs(nil))   = typedConstraints(nil) .
    ceq attachConstraintTypes(TIDS, cs(C Cs)) = typedConstraints(attachConstraintTypes(TIDS, C) TConstraint)
        if TConstraint := attachConstraintTypes(TIDS, cs(Cs)) .

    op functype : NeList{TypedId} -> EnkiType .
    eq functype(tid(Id, T))   = T .
    eq functype(tid(Id, T) L) = func(T, functype(L)) .

    op ruletype : NeList{TypedId} -> EnkiType .
    eq ruletype(tid(Id, T))   = T .
    eq ruletype(tid(Id, T) L) = rule(T, ruletype(L)) .

    op datatype : NeList{TypedId} -> EnkiType .
    eq datatype(tid(Id, T))   = T .
    eq datatype(tid(Id, T) L) = data(T, datatype(L)) .

    op funcTypeList : EnkiType -> List{EnkiType} .
    eq funcTypeList(func(T1, T2)) = T1 funcTypeList(T2) .
    eq funcTypeList(data(T1, T2)) = T1 funcTypeList(T2) .
    eq funcTypeList(rule(T1, T2)) = T1 funcTypeList(T2) .
    eq funcTypeList(T)            = T [owise] .

    op unifyMap : Set{TypedId} List{EnkiType} List{String} Map{String, Id} -> Set{TypedId} .
    eq unifyMap(TIDS, Types, nil, VarMap) = TIDS .
    eq unifyMap(TIDS, T Types, S Strs, (S |-> Id, VarMap)) = unifyMap(inferId(unifyType(TIDS, Id, T), Id), Types, Strs, VarMap) .

    --- TODO: Weird that we need to unify again at the end for the first case (equality)--unifyAll should take care of this for us?
    --- TODO: handle builtins better
    var FuncType : EnkiType .
    op inferId : Set{TypedId} Id -> Set{TypedId} .
    ceq inferId(TIDS, Id) = unify(inferId(inferId(unify(unify(TIDS, Id1, Id2), Id, Id1), Id1), Id2), Id1, Id2)
        if comp(Id1 s("=") Id2) := Id .
    ceq inferId(TIDS, Id) = inferId(inferId(unify(unify(unifyType(TIDS, Id1, int), Id2, Id1), Id, Id1), Id1), Id2)
        if comp(Id1 s(S) Id2) := Id /\
           (isArith(S) or isIntComp(S)) .
    ceq inferId(TIDS, Id) = inferId(inferId(unify(unify(unifyType(TIDS, Id1, string), Id1, Id2), Id, Id1), Id1), Id2)
        if comp(Id1 s(S) Id2) := Id /\
           isStrOp(S) .
    ceq inferId(TIDS, Id) = unifyType(unifyMap(TIDS, Types, varstrs(FuncId), VarMap), Id, T)
        if tid(FuncId, FuncType) := findFuncType(builtinsIds, Id) /\
           T                     := returnType(FuncType)   /\
           Types                 := funcTypeList(FuncType) /\
           VarMap                := funcUnify(FuncId, Id) .
    ceq inferId(TIDS, Id) = unifyType(unifyMap(TIDS, Types, varstrs(FuncId), VarMap), Id, T)
        if tid(FuncId, FuncType) := findFuncType(TIDS, Id) /\
           T                     := returnType(FuncType)   /\
           Types                 := funcTypeList(FuncType) /\
           VarMap                := funcUnify(FuncId, Id) .
    eq inferId(TIDS, Id) = TIDS [owise] .

    vars C C1 C2 : Constraint .
    var Cs : List{Constraint} .
    op inferConstraint : Set{TypedId} Constraint -> Set{TypedId} .
    eq inferConstraint(TIDS, c(Id))    = inferId(TIDS, Id) .
    eq inferConstraint(TIDS, when(C1, C2)) = inferConstraint(inferConstraint(TIDS, C1), C2) .
    eq inferConstraint(TIDS, cs(nil))  = TIDS .
    eq inferConstraint(TIDS, cs(C Cs)) = inferConstraint(inferConstraint(TIDS, C), cs(Cs)) .

    op makeFuncType : Set{TypedId} Id Id -> EnkiType .
    eq makeFuncType(TIDS, Id1, Id2) = functype(attachVars(TIDS, varlist(Id1)) attachType(TIDS, Id2)) .

    op makeRuleType : Set{TypedId} Id -> EnkiType .
    eq makeRuleType(TIDS, RuleId) = ruletype(attachVars(TIDS, varlist(RuleId))) .

    var VarMap : Map{String, Id} .

    var DummyT : EnkiType .
    var ResolvedId : Id .

    op resolveMap : Set{TypedId} Map{String, Id} -> Map{String, Id} .
    eq resolveMap(TIDS, empty) = empty .
    ceq resolveMap(TIDS, (S |-> Id, VarMap)) = (S |-> ResolvedId, resolveMap(TIDS, VarMap))
        if DummyT := firstUnused(types(TIDS), 0) /\
           tid(ResolvedId, DummyT) := resolve(TIDS, tid(Id, DummyT)) .

    var BuiltInSet : Set{Builtin} .

    op resolve : Set{TypedId} TypedId -> TypedId .
    eq resolve(TIDS,  tid(v(S), T))     = tid(v(S), T) .
    eq resolve(TIDS,  tid(b(B), T))     = tid(b(B), T) .
    eq resolve(TIDS,  tid(i(I), T))     = tid(i(I), T) .
    eq resolve(TIDS,  tid(s(S), T))     = tid(s(S), T) .
    ceq resolve(TIDS, tid(t(Id, T), T)) = tid(t(Id1, T), T)
        if tid(Id1, T1) := resolve(TIDS, tid(Id, T)) .
    eq resolve(TIDS,  tid(comp(nil), T)) = tid(comp(nil), T) .
    --- Check if this is some builtin, and look it up, if so
    ceq resolve(TIDS, tid(Id, T1)) = tid(fcall(ResolvedId, T, resolveMap(TIDS, VarMap)), T1)
        if tid(FuncId, T)                            := findFuncType(builtinsIds, Id) /\
           VarMap                                    := funcUnify(FuncId, Id) /\
           (builtin(FuncId, ResolvedId), BuiltInSet) := builtinsNames .
    --- Lookup the function call, if applicable
    ceq resolve(TIDS, tid(Id, T1)) = tid(fcall(FuncId, T, resolveMap(TIDS, VarMap)), T1)
        if tid(FuncId, T) := findFuncType(TIDS, Id) /\
           VarMap         := funcUnify(FuncId, Id) .
    --- Otherwise, resolve each in sequence (important for things like "X + Y")
    ceq resolve(TIDS, tid(comp(Id Ids), T1)) = tid(prependIds(Id1, Id2), T1)
        --- Generate a new dummy types (if necessary)
        if DummyT := firstUnused(types(TIDS), 0) /\
           tid(Id1, DummyT) := resolve(TIDS, tid(Id, DummyT)) /\
           tid(Id2, DummyT) := resolve(TIDS, tid(comp(Ids), DummyT)) .
    eq resolve(TIDS, tid(Id, T)) = resolveError(Id) .

    var TConstraint : TypedConstraint .
    var TConstraints : List{TypedConstraint} .
    vars TCs1 TCs2 : List{TypedConstraint} .

    var ResolvedTID : TypedId .

    vars TConstraint1 TConstraint2 : TypedConstraint .
    var Resolved : TypedConstraint .
    var ResolvedConstraints : List{TypedConstraint} .

    op resolve : Set{TypedId} TypedConstraint -> TypedConstraint .
    eq resolve(TIDS, typedConstraints(nil)) = typedConstraints(nil) .
    ceq resolve(TIDS, typedConstraints(TConstraint TConstraints)) =
        typedConstraints(Resolved ResolvedConstraints)
        if Resolved := resolve(TIDS, TConstraint) /\
           typedConstraints(ResolvedConstraints) := resolve(TIDS, TConstraints) .
    eq resolve(TIDS, typedWhen(TConstraint1, TConstraint2)) =
        typedWhen(resolve(TIDS, TConstraint1), resolve(TIDS, TConstraint2)) .
    ceq resolve(TIDS, typed(TID)) = constraintResolveError(Id)
        if resolveError(Id) := resolve(TIDS, TID) .
    ceq resolve(TIDS, typed(TID)) = typed(ResolvedTID)
        if ResolvedTID := resolve(TIDS, TID) .

    var Constraint : Constraint .
    var FinalTIDS : Set{TypedId} .
    op inferFunc : Set{TypedId} EnkiFunc -> TypedFunc .
    ceq inferFunc(TIDS, f(Id1, Constraint, e(Id2))) = handleFuncError(Id1, FuncType, TConstraint, TExpr)
        if Ids         := append(idList(Id1), append(idList(Id2), constraintIds(Constraint))) /\
           NewTIDS     := inferId(inferConstraint(freshtypes(TIDS, Ids), Constraint), Id2) /\
           FuncType    := makeFuncType(NewTIDS, Id1, Id2) /\
           FinalTIDS   := unifyType(NewTIDS, fid(Id1), FuncType) /\
           TExpr       := typedExpr(check(resolve(FinalTIDS, attachType(NewTIDS, Id2)))) /\
           TConstraint := check(resolve(FinalTIDS, attachConstraintTypes(NewTIDS, Constraint))) .

    var RuleId : Id .
    var RuleType : EnkiType .
    op inferRule : Set{TypedId} EnkiRule -> TypedRule .
    ceq inferRule(TIDS, r(RuleId, Constraint)) = handleRuleError(RuleId, RuleType, TConstraint)
        if Ids  := append(idList(RuleId), constraintIds(Constraint)) /\
           NewTIDS     := inferConstraint(freshtypes(TIDS, Ids), Constraint) /\
           RuleType    := makeRuleType(NewTIDS, RuleId) /\
           FinalTIDS   := unifyType(NewTIDS, fid(RuleId), RuleType) /\
           TConstraint := check(resolve(FinalTIDS, attachConstraintTypes(FinalTIDS, Constraint))) .

    var Defs : List{EnkiDef} .
    var Func : EnkiFunc .
    var Rule : EnkiRule .
    var TRule : TypedRule .

    --- These exist to allow functions/rules to call themselves
    --- It just provides a dummy type that has no type information, it just serves to say the definition exists.
    op dummyFuncType : Set{TypedId} Id -> Set{TypedId} .
    ceq dummyFuncType(TIDS, Id) = (tid(fid(Id), FuncType), TIDS)
        if NewTIDS  := freshtypes(TIDS, varlist(Id)) /\
           any(S)   := firstUnused(types(NewTIDS), 0) /\
           FuncType := functype(attachVars((tid(v(S), any(S)), NewTIDS), varlist(Id)) tid(v(S), any(S))) .

    op dummyRuleType : Set{TypedId} Id -> Set{TypedId} .
    ceq dummyRuleType(TIDS, Id) = (tid(fid(Id), FuncType), TIDS)
        if NewTIDS  := freshtypes(TIDS, varlist(Id)) /\
           FuncType := ruletype(attachVars(TIDS, varlist(Id))) .

    var Constructor : Constructor .
    var Constructors : List{Constructor} .
    var Field : Field .
    var Fields : List{Field} .

    op fieldTypes : List{Field} -> List{TypedId} .
    eq fieldTypes(nil) = nil .
    eq fieldTypes(field(Id, T) Fields) = tid(Id, T) fieldTypes(Fields) .

    var TypeId : Id .
    op constructorType : Id Constructor -> TypedId .
    eq constructorType(TypeId, constructor(Id, Fields)) = tid(fid(Id), datatype(fieldTypes(Fields) tid(TypeId, type(TypeId)))) .

    op constructorTypes : Id List{Constructor} -> Set{TypedId} .
    eq constructorTypes(Id, nil) = empty .
    eq constructorTypes(Id, Constructor Constructors) = constructorType(Id, Constructor), constructorTypes(Id, Constructors) .

    var Expr : Expr .
    var MoreDefs : List{EnkiDef} .

    op handleInferError : Set{TypedId} TypedDef List{EnkiDef} -> List{TypedDef} .
    eq handleInferError(TIDS, exec(typedExec(TConstraint)), Defs) = exec(typedExec(TConstraint)) inferDefs(TIDS, Defs) .
    ceq handleInferError(TIDS, def(TFunc), Defs) = def(TFunc) inferDefs((tid(fid(Id), T), TIDS), Defs)
        if typed(Id, T, TConstraint, TExpr) := TFunc .
    ceq handleInferError(TIDS, def(TRule), Defs) = def(TRule) inferDefs((tid(fid(Id), T), TIDS), Defs)
        if typed(Id, T, TConstraint) := TRule .
    eq handleInferError(TIDS, def(resolveFuncError(FuncId, Id)), Defs) = def(resolveFuncError(FuncId, Id)) .
    eq handleInferError(TIDS, def(resolveRuleError(RuleId, Id)), Defs) = def(resolveRuleError(RuleId, Id)) .

    op inferDefs : Set{TypedId} List{EnkiDef} -> List{TypedDef} .
    eq inferDefs(TIDS, nil) = nil .
    eq inferDefs(TIDS, import(m(MoreDefs)) Defs) = inferDefs(TIDS, append(MoreDefs, Defs)) .
    ceq inferDefs(TIDS, exec(ex(Constraint)) Defs) = handleInferError(TIDS, exec(typedExec(TConstraint)), Defs)
        if NewTIDS     := inferConstraint(freshtypes(TIDS, constraintIds(Constraint)), Constraint) /\
           TConstraint := check(resolve(NewTIDS, attachConstraintTypes(NewTIDS, Constraint))) .
    ceq inferDefs(TIDS, def(Func) Defs) = handleInferError(TIDS, def(TFunc), Defs)
        if f(FuncId, C, Expr)               := Func /\
           TFunc                            := inferFunc(dummyFuncType(TIDS, FuncId), Func) .
    ceq inferDefs(TIDS, def(Rule) Defs) = handleInferError(TIDS, def(TRule), Defs)
        if r(RuleId, C)              := Rule /\
           TRule                     := inferRule(dummyRuleType(TIDS, RuleId), Rule) .
    ceq inferDefs(TIDS, def(d(Id, Constructors)) Defs) = inferDefs((NewTIDS, TIDS), Defs)
        if NewTIDS := constructorTypes(Id, Constructors) .
endm

