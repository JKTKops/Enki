load enki-typechecking.maude
load utility.maude

mod ENKI-CODEGEN is
    protecting ENKI-TYPECHECK .
    protecting UTILITY .

    protecting CONVERSION .
    protecting MAP{String, String} .

    sort GenResult .

    op genRes : Int Map{String, String} List{String} -> GenResult .

    var Id Id1 Id2 : Id .
    vars S S1 S2 : String .
    vars Strs Current : List{String} .
    var I NewI : Int .
    var T T2 : EnkiType .
    var Types : List{EnkiType} .
    var Tid : TypedId .
    vars Name ResName Params : String .

    op eqSign : EnkiType -> String .
    ceq eqSign(T) = "#="
        if returnType(T) = int .
    eq eqSign(T) = "=" [owise] .

    op prologArith : String -> String .
    eq prologArith("+") = "+" .
    eq prologArith("-") = "-" .
    eq prologArith("/") = "div" .
    eq prologArith("*") = "*" .
    eq prologArith("^") = "^" .

    var VarMap FuncMap : Map{String, Id} .
    var Ids : List{Id} .
    var FuncId : Id .
    var NewLine : String .

    var FuncTypes : List{EnkiType} .

    vars StrVarMap NewVarMap : Map{String, String} .

    op mapVars : List{String} Map{String, String} -> List{String} .
    eq mapVars(nil, StrVarMap) = nil .
    eq mapVars(S Strs, (S |-> S2, StrVarMap)) = S2 mapVars(Strs, StrVarMap) .

    op idMap : List{String} -> Map{String, String} .
    eq idMap(nil) = empty .
    eq idMap(S Strs) = (S |-> S, idMap(Strs)) .

    op funcName : Id -> String .
    eq funcName(FuncId) = intercalate("_", nonVarStrs(FuncId)) .

    op genFuncCallParams : Id Map{String, String} String -> String .
    eq genFuncCallParams(FuncId, StrVarMap, ResName) =
        funcName(FuncId) + "(" + intercalate(",", mapVars(varstrs(varlist(FuncId)), StrVarMap) ResName) + ")" .

    op genFuncCall : Id String -> String .
    eq genFuncCall(FuncId, ResName) = genFuncCallParams(FuncId, idMap(varstrs(varlist(FuncId))), ResName) .

    var NewLines Lines : List{String} .
    vars I1 I2 FinalI : Int .
    vars Vars1 Vars2 : Map{String, Id} .

    vars Line NewIdStr Str : String .
    var TempVarMap AllVars : Map{String, String} .

    op genParams : List{EnkiType} List{Id} Map{String, Id} List{String} Int -> GenResult .
    eq genParams(Types, nil, VarMap, Current, I) = genRes(I, empty, Current) .
    ceq genParams(T Types, v(S) Ids, (S |-> fcall(FuncId, FuncTypes, FuncMap), VarMap), Current, I) =
        genRes(FinalI, (S |-> NewIdStr, AllVars), NewLines)
        if genRes(NewI, NewVarMap, Lines) := genParams(FuncTypes, varlist(FuncId), FuncMap, nil, I) /\
           NewIdStr                      := "Temp" + string(NewI, 10) /\
           NewLine                       := genFuncCallParams(FuncId, NewVarMap, NewIdStr) /\
           genRes(FinalI, AllVars, NewLines)  := genParams(Types, Ids, VarMap, append(Lines NewLine, Current), NewI + 1) .
    ceq genParams(T Types, v(S) Ids, (S |-> Id, VarMap), Current, I) =
        genRes(FinalI, (S |-> NewIdStr, NewVarMap), Lines)
        if NewIdStr                       := "Temp" + string(I, 10) /\
           NewLine                        := NewIdStr + " " + eqSign(T) + " " + genId(Id) /\
           genRes(FinalI, NewVarMap, Lines) := genParams(Types, Ids, VarMap, NewLine Current, I + 1) .

    op genId : Id -> List{String} .
    eq genId(v(S)) = S .
    eq genId(s(S)) = "\"" + S + "\"" .
    eq genId(i(I)) = string(I, 10) .
    ceq genId(comp(Id1 s(S) Id2)) = "(" + genId(Id1) + " " + prologArith(S) + " " + genId(Id2) + ")"
        if isArith(S) .

    op genFunc : TypedFunc -> List{String} .
    ceq genFunc(typedf(Id, T, typedExpr(tid(fcall(FuncId, Types, VarMap), T2)))) =
        (genFuncCall(Id, ResName) + " :- ")
        Lines
        genFuncCallParams(FuncId, AllVars, ResName)
        if ResName := "Result_" + funcName(Id) /\
           genRes(FinalI, AllVars, Lines) := genParams(Types, varlist(FuncId), VarMap, nil, 0) .
    ceq genFunc(typedf(FuncId, T, typedExpr(tid(Id2, T2)))) =
        genFuncCall(FuncId, ResName) + " :- " + ResName + " " + eqSign(T) + " " + genId(Id2)
        if ResName := "Result_" + funcName(FuncId) [owise] .

    var TFunc : TypedFunc .
    var TFuncs : List{TypedFunc} .
    op genFuncs : List{TypedFunc} -> String .
    eq genFuncs(nil)           = "" .
    ceq genFuncs(TFunc TFuncs) = intercalate("\n\n", NewLine genFuncs(TFuncs))
        if (Line Lines) := genFunc(TFunc) /\
           NewLine := if isEmpty(Lines) then (Line + ".") else (Line + "\n    " + intercalate(",\n    ", Lines) + ".") fi .

    op genHeader : -> String .
    eq genHeader = "#!/usr/bin/env swipl\n\n:- use_module(library(clpfd))." .

    op genFile : List{TypedFunc} -> String .
    eq genFile(TFuncs) = genHeader + "\n\n" + genFuncs(TFuncs) .
endm

