mod ENKI-CODEGEN is
    protecting ENKI-TYPECHECK .
    protecting UTILITY .

    protecting CONVERSION .
    protecting MAP{String, String} .

    var Id Id1 Id2 : Id .
    vars S S1 S2 : String .
    vars Strs Current : List{String} .
    var I NewI : Int .
    var T T2 : EnkiType .
    var Types : List{EnkiType} .
    var Tid : TypedId .
    vars Name ResName : String .

    op eqSign : EnkiType -> String .
    ceq eqSign(T) = "#="
        if returnType(T) = int .
    eq eqSign(T) = "=" [owise] .

    op prologArith : String -> String .
    eq prologArith("+") = "+" .
    eq prologArith("-") = "-" .
    eq prologArith("/") = "div" .
    eq prologArith("*") = "*" .
    eq prologArith("^") = "^" .

    var VarMap : Map{String, Id} .
    var Ids : List{Id} .
    var FuncId : Id .
    var NewLine : String .

    var StrVarMap : Map{String, String} .

    op mapVars : List{String} Map{String, String} -> List{String} .
    eq mapVars(nil, StrVarMap) = nil .
    eq mapVars(S Strs, (S |-> S2, StrVarMap)) = S2 mapVars(Strs, StrVarMap) .

    op idMap : List{String} -> Map{String, String} .
    eq idMap(nil) = empty .
    eq idMap(S Strs) = (S |-> S, idMap(Strs)) .

    op funcName : Id -> String .
    eq funcName(FuncId) = intercalate("_", nonVarStrs(FuncId)) .

    var Params : List{String} .
    op genFuncCallParams : Id Map{String, String} String -> String .
    ceq genFuncCallParams(FuncId, StrVarMap, ResName) =
        funcName(FuncId) + "(" + intercalate(",", mapVars(varstrs(FuncId), StrVarMap) ResName) + ")"
        if Params := mapVars(varstrs(FuncId), StrVarMap) (if ResName == "" then nil else ResName fi) .

    op genFuncCall : Id String -> String .
    eq genFuncCall(FuncId, ResName) = genFuncCallParams(FuncId, idMap(varstrs(FuncId)), ResName) .

    var NewLines Lines : List{String} .
    vars I1 I2 FinalI : Int .
    vars Vars1 Vars2 : Map{String, Id} .

    vars Line NewIdStr Str : String .
    var TempVarMap AllVars : Map{String, String} .

    --- Represents a value that was generated, with the lines to generate it, the name of the variable the result
    --- was stored in, and the fresh var counter number after generating it.
    sort GenVal .
    op genVal : List{String} String Int -> GenVal .

    sort ParamRes .
    op paramRes : List{String} Map{String, String} Int -> ParamRes .

    op genParams : List{EnkiType} List{Id} Map{String, Id} Int -> ParamRes .
    eq genParams(Types, nil, VarMap, Counter)                     = paramRes(nil, empty, Counter) .
    ceq genParams(T Types, v(S) Ids, (S |-> Id, VarMap), Counter) =
        paramRes(append(Lines1, Lines2), (S |-> ResName, AllVars), FinalI)
        if genVal(Lines1, ResName, Counter1) := generate(tid(Id, T), Counter + 1) /\
           paramRes(Lines2, AllVars, FinalI) := genParams(Types, Ids, VarMap, Counter1 + 1) .

    vars Counter Counter1 Counter2 : Int .
    vars Lines1 Lines2 : List{String} .
    vars Res1 Res2 : String .

    var Op : String .
    op genPrologOp : EnkiType String String String String -> String .
    eq genPrologOp(T, "..", NewIdStr, Res1, Res2) =
        "atom_concat(" + Res1 + "," + Res2 + "," + NewIdStr + ")" .
    eq genPrologOp(T, "=", NewIdStr, Res1, Res2) =
        Res1 + " = " + Res2 . --- NewIdStr is unused, because this is an expression, so we don't care about the result
    ceq genPrologOp(T, S, NewIdStr, Res1, Res2) =
        NewIdStr + " " + eqSign(T) + " " + Res1 + " " + prologArith(S) + " " + Res2
        if isArith(S) .

    op generate : TypedId Int -> GenVal .
    eq generate(tid(b(true), T), Counter)  = genVal(nil, "true", Counter) .
    eq generate(tid(b(false), T), Counter) = genVal(nil, "false", Counter) .
    eq generate(tid(i(I), T), Counter)     = genVal(nil, string(I, 10), Counter) .
    eq generate(tid(v(S), T), Counter)     = genVal(nil, S, Counter) .
    eq generate(tid(s(S), T), Counter)     = genVal(nil, S, Counter) .
    eq generate(tid(t(Id, T), T), Counter) = generate(tid(Id, T), Counter) .
    eq generate(tid(comp(Id), T), Counter) = generate(tid(Id, T), Counter) .
    ceq generate(tid(fcall(FuncId, Types, VarMap), T), Counter) =
        genVal(Lines NewLine, NewIdStr, FinalI + 1)
        if paramRes(Lines, AllVars, FinalI) := genParams(Types, varlist(FuncId), VarMap, Counter + 1) /\
           NewIdStr                         := "Temp" + string(Counter, 10) /\
           NewLine                          := genFuncCallParams(FuncId, AllVars, NewIdStr) .
    --- Handle arithmetic operations
    ceq generate(tid(comp(Id1 s(S) Ids), T), Counter) =
        genVal(append(Lines1, Lines2 NewLine), NewIdStr, Counter2 + 1)
        if (isArith(S) or isStrOp(S) or (S == "=")) /\
           genVal(Lines1, Res1, Counter1) := generate(tid(Id1, T), Counter + 1) /\
           genVal(Lines2, Res2, Counter2) := generate(tid(comp(Ids), T), Counter1 + 1) /\
           NewIdStr                       := "Temp" + string(Counter, 10) /\
           NewLine                        := genPrologOp(T, S, NewIdStr, Res1, Res2) .

    var C : TypedConstraint .
    var Cs : List{TypedConstraint} .
    op generateConstraint : TypedConstraint Int -> GenVal .
    eq generateConstraint(typedConstraint(TID), Counter)    = generate(TID, Counter) .
    eq generateConstraint(typedConstraints(nil), Counter)   = genVal(nil, "Unused", Counter) .
    ceq generateConstraint(typedConstraints(C Cs), Counter) = genVal(append(Lines1, Lines2), Res2, Counter2)
        if genVal(Lines1, Res1, Counter1) := generateConstraint(C, Counter) /\
           genVal(Lines2, Res2, Counter2) := generateConstraint(typedConstraints(Cs), Counter1) .

    var TID : TypedId .
    op genFunc : TypedFunc -> List{String} .
    ceq genFunc(typed(FuncId, T, C, typedExpr(TID))) =
        append((genFuncCall(FuncId, Res2) + " :- ") Lines1, Lines2)
        if genVal(Lines1, Res1, Counter)  := generateConstraint(C, 0) /\
           genVal(Lines2, Res2, Counter1) := generate(TID, Counter) .

    var TFunc : TypedFunc .
    var TDefs : List{TypedDef} .
    op genDefs : List{TypedDef} -> String .
    eq genDefs(nil)           = "" .
    ceq genDefs(def(TFunc) TDefs) = intercalate("\n\n", NewLine genDefs(TDefs))
        if (Line Lines) := genFunc(TFunc) /\
           NewLine := Line + "\n    " + intercalate(",\n    ", Lines) + "." .

    op genHeader : -> String .
    eq genHeader = "#!/usr/bin/env swipl\n\n:- use_module(library(clpfd))." .

    op genFile : List{TypedDef} -> String .
    eq genFile(TDefs) = genHeader + "\n\n" + genDefs(TDefs) .
endm

