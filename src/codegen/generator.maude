mod ENKI-CODEGEN is
    protecting ENKI-TYPECHECK .
    protecting UTILITY .

    protecting ENKI-CODEGEN-SORTS .

    protecting CONVERSION .
    protecting LIST{Line} .
    protecting LIST{TypedExec} .
    protecting MAP{String, String} .

    var Id Id1 Id2 : Id .
    vars S S1 S2 : String .
    vars Strs Current : List{String} .
    var I NewI : Int .
    var T T2 : EnkiType .
    var Types : List{EnkiType} .
    var Tid : TypedId .
    vars Name ResName : String .

    op eqSign : EnkiType -> String .
    ceq eqSign(T) = "#="
        if returnType(T) = int .
    eq eqSign(T) = "=" [owise] .

    op prologArith : String -> String .
    eq prologArith("+") = "+" .
    eq prologArith("-") = "-" .
    eq prologArith("/") = "div" .
    eq prologArith("*") = "*" .
    eq prologArith("^") = "^" .

    op prologComp : String -> String .
    eq prologComp(">") = "#>" .
    eq prologComp("<") = "#<" .
    eq prologComp(">=") = "#>=" .
    eq prologComp("<=") = "#=<" .

    var VarMap : Map{String, Id} .
    var Ids : List{Id} .
    var FuncId : Id .
    var NewLine : Line .

    var StrVarMap : Map{String, String} .

    op mapVars : List{String} Map{String, String} -> List{String} .
    eq mapVars(nil, StrVarMap) = nil .
    eq mapVars(S Strs, (S |-> S2, StrVarMap)) = S2 mapVars(Strs, StrVarMap) .

    op idMap : List{String} -> Map{String, String} .
    eq idMap(nil) = empty .
    eq idMap(S Strs) = (S |-> S, idMap(Strs)) .

    op funcName : Id -> String .
    eq funcName(FuncId) = intercalate("_", nonVarStrs(FuncId)) .

    var Params : List{String} .
    op genFuncCallParams : Id Map{String, String} String -> String .
    eq genFuncCallParams(FuncId, empty, ResName) =
        if ResName == "" then funcName(FuncId) else (funcName(FuncId) + "(" + ResName + ")") fi .
    ceq genFuncCallParams(FuncId, StrVarMap, ResName) =
        funcName(FuncId) + "(" + intercalate(",", Params) + ")"
        if Params := mapVars(varstrs(FuncId), StrVarMap) (if ResName == "" then nil else ResName fi) .

    op genFuncCall : Id String -> String .
    ceq genFuncCall(FuncId, ResName) = funcName(FuncId)
        if varstrs(FuncId) == nil .
    eq genFuncCall(FuncId, ResName) = genFuncCallParams(FuncId, idMap(varstrs(FuncId)), ResName) [owise] .

    var NewLines Lines : List{Line} .
    vars I1 I2 FinalI : Int .
    vars Vars1 Vars2 : Map{String, Id} .

    vars Line NewIdStr Str : String .
    var TempVarMap AllVars : Map{String, String} .

    --- Represents a value that was generated, with the lines to generate it, the name of the variable the result
    --- was stored in, and the fresh var counter number after generating it.
    sort GenVal .
    op genVal : List{Line} String Int -> GenVal .

    sort ParamRes .
    op paramRes : List{Line} Map{String, String} Int -> ParamRes .

    op genParams : List{EnkiType} List{Id} Map{String, Id} Int -> ParamRes .
    eq genParams(Types, nil, VarMap, Counter)                     = paramRes(nil, empty, Counter) .
    ceq genParams(T Types, v(S) Ids, (S |-> Id, VarMap), Counter) =
        paramRes(append(Lines1, Lines2), (S |-> ResName, AllVars), FinalI)
        if genVal(Lines1, ResName, Counter1) := generate(tid(Id, T), Counter + 1) /\
           paramRes(Lines2, AllVars, FinalI) := genParams(Types, Ids, VarMap, Counter1 + 1) .

    vars Counter Counter1 Counter2 : Int .
    vars Lines1 Lines2 : List{Line} .
    vars Res1 Res2 : String .

    var Op : String .
    op genPrologOp : EnkiType String String String String -> String .
    eq genPrologOp(T, "..", NewIdStr, Res1, Res2) =
        "atom_concat(" + Res1 + "," + Res2 + "," + NewIdStr + ")" .
    eq genPrologOp(T, "=", NewIdStr, Res1, Res2) =
        Res1 + " = " + Res2 . --- NewIdStr is unused, because this is an expression, so we don't care about the result
    ceq genPrologOp(T, S, NewIdStr, Res1, Res2) =
        NewIdStr + " " + eqSign(T) + " " + Res1 + " " + prologArith(S) + " " + Res2
        if isArith(S) .
    ceq genPrologOp(T, S, NewIdStr, Res1, Res2) =
        Res1 + " " + prologComp(S) + " " + Res2
        if isIntComp(S) .

    var Type : EnkiType .

    op isData : EnkiType -> Bool .
    eq isData(type(Id))    = true .
    eq isData(data(T, T2)) = true .

    op generate : TypedId Int -> GenVal .
    eq generate(tid(b(true), T), Counter)  = genVal(nil, "true", Counter) .
    eq generate(tid(b(false), T), Counter) = genVal(nil, "false", Counter) .
    eq generate(tid(i(I), T), Counter)     = genVal(nil, string(I, 10), Counter) .
    eq generate(tid(v(S), T), Counter)     = genVal(nil, S, Counter) .
    eq generate(tid(s(S), T), Counter)     = genVal(nil, S, Counter) .
    eq generate(tid(t(Id, T), T), Counter) = generate(tid(Id, T), Counter) .
    eq generate(tid(comp(Id), T), Counter) = generate(tid(Id, T), Counter) .
    ceq generate(tid(fcall(FuncId, Type, VarMap), T), Counter) =
        genVal(Lines, ResName, FinalI + 1)
        if isData(Type) /\
           paramRes(Lines, AllVars, FinalI) := genParams(typeList(Type), varlist(FuncId), VarMap, Counter + 1) /\
           ResName                          := genFuncCallParams(FuncId, AllVars, "") .
    ceq generate(tid(fcall(FuncId, Type, VarMap), T), Counter) =
        genVal(Lines NewLine, NewIdStr, FinalI + 1)
        if paramRes(Lines, AllVars, FinalI) := genParams(typeList(Type), varlist(FuncId), VarMap, Counter + 1) /\
           NewIdStr                         := "Temp" + string(Counter, 10) /\
           NewLine                          := andline(genFuncCallParams(FuncId, AllVars, if isFunc(Type) then NewIdStr else "" fi)) .
    --- Handle arithmetic operations
    ceq generate(tid(comp(Id1 s(S) Ids), T), Counter) =
        genVal(append(Lines1, Lines2 NewLine), NewIdStr, Counter2 + 1)
        if (isArith(S) or isStrOp(S) or (S == "=") or isIntComp(S)) /\
           genVal(Lines1, Res1, Counter1) := generate(tid(Id1, T), Counter + 1) /\
           genVal(Lines2, Res2, Counter2) := generate(tid(comp(Ids), T), Counter1 + 1) /\
           NewIdStr                       := "Temp" + string(Counter, 10) /\
           NewLine                        := andline(genPrologOp(T, S, NewIdStr, Res1, Res2)) .

    vars C TConstraint1 TConstraint2 : TypedConstraint .
    var Cs : List{TypedConstraint} .
    var ThenLines : List{Line} .
    op generateConstraint : TypedConstraint Int -> GenVal .
    eq generateConstraint(typedConstraint(TID), Counter)    = generate(TID, Counter) .
    ceq generateConstraint(typedWhen(TConstraint1, TConstraint2), Counter) =
        genVal(synline("(") NewLines orline(")"), Res2, Counter2)
        if genVal(Lines1, Res1, Counter1) := generateConstraint(TConstraint1, Counter) /\
           genVal(Lines2, Res2, Counter2) := generateConstraint(TConstraint2, Counter1) /\
           NewLine := synline(str(last(Lines1)) + if Lines2 == nil then "" else " -> " fi) /\
           --- ThenLines are the lines inside the "->" part.
           --- They need to be changed because we need to make sure that they don't end with a "," or ";"
           ThenLines := if Lines2 == nil then nil else front(Lines2) synline(str(last(Lines2))) fi /\
           NewLines := append(front(Lines1) NewLine, ThenLines) .
    eq generateConstraint(typedConstraints(nil), Counter)   = genVal(nil, "Unused", Counter) .
    ceq generateConstraint(typedConstraints(C Cs), Counter) = genVal(append(Lines1, Lines2), Res2, Counter2)
        if genVal(Lines1, Res1, Counter1) := generateConstraint(C, Counter) /\
           genVal(Lines2, Res2, Counter2) := generateConstraint(typedConstraints(Cs), Counter1) .

    var TID : TypedId .
    op genFunc : TypedFunc -> List{Line} .
    ceq genFunc(typed(FuncId, T, C, typedExpr(TID))) =
        append(hornline(genFuncCall(FuncId, Res2)) Lines1, Lines2)
        if genVal(Lines1, Res1, Counter)  := generateConstraint(C, 0) /\
           genVal(Lines2, Res2, Counter1) := generate(TID, Counter) .

    var RuleId : Id .
    op genRule : TypedRule -> List{Line} .
    ceq genRule(typed(RuleId, T, C)) = hornline(genFuncCall(RuleId, "")) Lines
        if genVal(Lines, ResName, Counter)  := generateConstraint(C, 0) .

    var L : Line .
    op combineLines : List{Line} -> String .
    eq combineLines(L) = str(L) + "." .
    eq combineLines(L Lines) = str(L) + lineend(L) + "\n    " + combineLines(Lines) .

    var TFunc : TypedFunc .
    var TRule : TypedRule .
    var TDefs : List{TypedDef} .
    op genDefs : List{TypedDef} -> String .
    eq genDefs(nil)           = "" .
    ceq genDefs(def(TFunc) TDefs) = intercalate("\n\n", S genDefs(TDefs))
        if Lines := genFunc(TFunc) /\
           S     := combineLines(Lines) .
    ceq genDefs(def(TRule) TDefs) = intercalate("\n\n", S genDefs(TDefs))
        if Lines := genRule(TRule) /\
           S     := combineLines(Lines) .

    op genHeader : -> String .
    eq genHeader = "#!/usr/bin/env swipl\n\n:- use_module(library(clpfd))." .

    sort Res .
    op res : List{TypedConstraint} List{TypedDef} -> Res .

    var Exec : TypedConstraint .
    var Execs : List{TypedConstraint} .
    var TDef : TypedDef .
    var RestDefs : List{TypedDef} .

    var TConstraint : TypedConstraint .

    op gatherExecs : List{TypedConstraint} List{TypedDef} List{TypedDef} -> Res .
    eq gatherExecs(Execs, TDefs, nil) = res(Execs, TDefs) .
    eq gatherExecs(Execs, TDefs, exec(typedExec(TConstraint)) RestDefs) = gatherExecs(Execs TConstraint, TDefs, RestDefs) .
    eq gatherExecs(Execs, TDefs, TDef RestDefs) = gatherExecs(Execs, TDefs TDef, RestDefs) .

    op styleChecksOff : -> String .
    eq styleChecksOff = ":- style_check(-singleton).\n:- style_check(-no_effect).\n:- style_check(-var_branches).\n:- style_check(-discontiguous).\n:- style_check(-charset)." .

    op genMain : List{TypedConstraint} -> String .
    eq genMain(nil)    = "" .
    ceq genMain(Execs) = ":- initialization(main, main).\n\n" + S + "\n\n"
        if S := genDefs(def(typed(comp(s("main") v("Args")), string, typedConstraints(Execs)))) .

    op genFile : List{TypedDef} -> String .
    ceq genFile(TDefs) = genHeader + "\n\n" + styleChecksOff + "\n\n" + genMain(Execs) + genDefs(RestDefs)
        if res(Execs, RestDefs) := gatherExecs(nil, nil, TDefs) .
endm

