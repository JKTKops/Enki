{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE FlexibleContexts #-}

module Enki.Parser.Parser where

import Control.Monad.IO.Class
import Control.Monad.Trans.State.Lazy

import Data.List
import Data.Maybe
import Data.String.Utils

import System.Directory
import System.Environment
import System.FilePath.Posix

import Text.Parsec
import Text.Parsec.Expr

import Enki.Types
import Enki.Parser.AST
import Enki.Parser.Util

type Parser a = forall s st m. Stream s m Char => ParsecT s st m a

parseFileAst :: String -> IO [Def]
parseFileAst fname = do
    enkiPath <- getEnv "ENKI_PATH"

    -- Load the standard library
    stdLib <- withCurrentDirectory enkiPath (parseDef =<< readFile "base.enki")

    let dir = takeDirectory fname
    let base = takeFileName fname

    res <- withCurrentDirectory dir (parseDef =<< readFile base)

    case (stdLib, res) of
        (Left err, _) -> error $ show err
        (_, Left err) -> error $ show err
        (Right stdLibParsed, Right parsed) -> pure $ fixImports $ Module "base" stdLibParsed : parsed

fixImports :: [Def] -> [Def]
fixImports defs = filter (noIgnore (concatMap ignore defs)) defs
    where
        noIgnore _ (NoImport _) = False -- Remove all of these
        noIgnore ignoredNames (Module name _) = name `notElem` ignoredNames
        noIgnore _ _ = True

        ignore (NoImport name) = [name]
        ignore _ = []

parseDef :: MonadIO m => String -> m (Either ParseError [Def])
parseDef = runParserT enkiDef () ""

enkiDef :: (MonadIO m, Stream s m Char) => ParsecT s st m [Def]
enkiDef = many (try enkiImport <|>
                try noImport <|>
                try func <|>
                try rule <|>
                try dataDef <|>
                try exec)

noImport :: (MonadIO m, Stream s m Char) => ParsecT s st m Def
noImport = do
    symbol $ string "do"
    symbol $ string "not"
    symbol $ string "use"
    moduleName <- symbol $ many $ noneOf " .\n\r\t"
    symbol $ string "."
    optional newlines

    pure $ NoImport moduleName

enkiImport :: (MonadIO m, Stream s m Char) => ParsecT s st m Def
enkiImport = do
    symbol $ string "use"
    -- TODO: Allow defining multiple modules per file
    moduleName <- symbol $ many $ noneOf " .\n\r\t"
    file <- optionMaybe $ do
        symbol $ string "from"
        symbol $ many $ noneOf " .\n\r\t"
    symbol $ string "."
    optional newlines

    let filename =
            case file of
                Nothing -> moduleName ++ ".enki"
                Just name -> if ".enki" `isSuffixOf` name then name else name ++ ".enki"

    -- TODO: Make this search multiple paths
    defs <- liftIO $ parseFileAst filename
    pure $ Module moduleName defs

exec :: Parser Def
exec = do
    lineSep
    c <- constraint
    symbol $ char '.'
    lineSep

    pure $ Exec c

lineSep :: Parser ()
lineSep = do
    wsSkip
    optional newlines
    wsSkip

rule :: Parser Def
rule = do
    lineSep
    tempId <- enkiId "" ["if", "where"]

    let (id, argConstrs) = replaceCompArgs tempId

    lineSep
    choice $ map string ["if", "where"]
    lineSep
    c <- constraint
    lineSep
    char '.'

    pure $ case c of
        c@(Constraint cid) -> Rule id $ Constraints $ argConstrs ++ [c]
        Constraints cs     -> Rule id $ Constraints $ argConstrs ++ cs
        When _ _           -> error "Cannot have a rule with only a when branch for it's body, must include an otherwise!"

funcResultVar = V "AUTOGENERATEDFUNCTIONRESULT"

replaceCompArgs :: Id -> (Id, [Constraint])
replaceCompArgs (Comp ids) =
    let (newIds, constraints) = unzip $ zipWith go [1..] ids
    in (Comp newIds, concat constraints)
    where
        go counter c@(Comp _) = (V freshArgId, [Constraint (Comp [V freshArgId, S "=", c])])
            where freshArgId = "AUTOGENARG" ++ show counter
        go counter i = (i, [])
replaceCompArgs i = (i, [])

func :: Parser Def
func = do
    tempId <- symbol $ enkiId "" ["is"]

    let (id, argConstrs) = replaceCompArgs tempId

    symbol $ string "is"
    constr <- symbol constraint
    symbol $ char '.'

    pure $ case constr of
        Constraint cid -> Func id (Constraints argConstrs) $ Expr cid
        Constraints cs | allWhenBranches (dropWhile (not . isWhen) cs) ->
            let ctrs = takeWhile (not . isWhen) cs
                whens = dropWhile (not . isWhen) cs
            in Func id (Constraints (argConstrs ++ ctrs ++ map makeResult whens)) $ Expr $ Comp [funcResultVar]

        Constraints cs ->
            let (Constraint cid) = last cs
            in Func id (Constraints (argConstrs ++ init cs)) $ Expr cid
        When _ _       -> error "Cannot have a function with only a when branch for it's body"

makeResult :: Constraint -> Constraint
makeResult (When cond (Constraints [])) = When (makeResult cond) $ Constraints []
makeResult (When cond body)             = When cond $ makeResult body
makeResult (Constraints cs)             = Constraints $ map go (init cs) ++ [makeResult (last cs)]
    where
        -- Need to process all the when's here to make sure we don't miss their results
        go (When cond body) = When cond $ makeResult body
        go c = c
makeResult c@(Constraint id) = Constraint $ Comp [funcResultVar, S "=", id]

isWhen (When _ _) = True
isWhen _          = False

allWhenBranches :: [Constraint] -> Bool
allWhenBranches constrs = all isWhen constrs && not (null constrs)

dataDef :: Parser Def
dataDef = do
    id <- symbol $ enkiId "" ["may", "be"]
    symbol $ string "may"
    symbol $ string "be"
    constructors <- many (symbol constructor)
    lineSep

    pure $ Data id constructors

constructor :: Parser Constructor
constructor = try constructorWithFields <|> try unitConstructor

unitConstructor :: Parser Constructor
unitConstructor = do
    id <- enkiId "" ["is","if","where"] -- Don't accidentally parse functions or rules
    symbol $ char '.'

    pure $ Constructor id []

constructorWithFields :: Parser Constructor
constructorWithFields = do
    id <- symbol $ enkiId "" ["has"]
    symbol $ string "has"
    fields <- sepBy1 field $ symbol $ string ","
    symbol $ char '.'
    pure $ Constructor id fields

field :: Parser Field
field = do
    id <- symbol $ baseEnkiId "" [":"]
    symbol $ string ":"
    t <- symbol enkiType

    pure $ Field id t

enkiType :: Parser Type
enkiType = do
    first <- singleEnkiType
    rest <- optionMaybe $ do
        sep <- try $ choice $ map (symbol . string) ["->", "~", "*"]
        second <- enkiType
        pure $ case sep of
            "->" -> (FuncType, second)
            "~"  -> (RuleType, second)
            "*"  -> (DataType, second)

    pure $ case rest of
        Nothing -> first
        Just (constr, second) -> constr first second

singleEnkiType :: Parser Type
singleEnkiType = choice $ map try [namedType "int" EnkiInt, namedType "bool" EnkiBool, namedType "string" EnkiString,
                                   parenType, dataTypeName]

dataTypeName :: Parser Type
dataTypeName = do
    id <- symbol $ baseEnkiId "" ["->", "~", "*"]
    pure $ case id of
        Comp [V s] -> Any s
        _ -> TypeName $ makeTypeName id

parenType :: Parser Type
parenType = between (symbol (string "(")) (symbol (string ")")) enkiType

namedType :: String -> Type -> Parser Type
namedType enkiTName enkiTConst = do
    symbol $ string enkiTName
    pure enkiTConst

connected :: String -> (Type -> Type -> Type) -> Parser Type
connected connector constr = foldl1 constr <$> sepBy1 enkiType (symbol (string connector))

expr :: Parser Expr
expr = Expr <$> enkiId "" []

constraint :: Parser Constraint
constraint = do
    constraints <- map Constraint <$> sepEndBy idParsers sep
    whenBranches <- sepBy1 (try when <|> try otherwiseBranch) lineSep <|> pure []

    pure $ Constraints $ constraints ++ whenBranches
    where
        ignoreWords = ["when", "then", "otherwise"]
        idParsers = do
            id <- try (enkiId "" ignoreWords) <|> try (baseEnkiId "" ignoreWords)
            case id of
                Comp [] -> parserZero
                _       -> pure id
        sep = symbol $ string ","

when :: Parser Constraint
when = do
    symbol $ string "when"
    condition <- constraint

    body <- optionMaybe $ do
        symbol $ string "then"
        body <- symbol constraint
        pure body
    symbol $ char '.'

    pure $ When condition $ fromMaybe (Constraints []) body

otherwiseBranch :: Parser Constraint
otherwiseBranch = do
    lineSep
    string "otherwise"
    lineSep
    string "then"
    lineSep
    body <- constraint
    lineSep

    pure $ When body $ Constraints []

withWs :: Stream s m Char => ParsecT s st m a -> ParsecT s st m a
withWs parser = do
    a <- parser
    wsSkip
    pure a

operators = ["=", "+", "-", "<=", ">=", "*", "/", "^", "..", "<", ">"]

sanitizeStr :: String -> String
sanitizeStr str
    | str `elem` operators = str
    | otherwise = fst $ foldl go ("", False) str
    where
        go (cur, inQuotes) c
            | c == '\"' = (cur ++ "\"", not inQuotes)
            | inQuotes  = (cur ++ [c], inQuotes)
            | otherwise = (cur ++ sanitizeChar c, inQuotes)

        sanitizeChar '|'  = "pipe_"
        sanitizeChar '-'  = "dash_"
        sanitizeChar '!'  = "exclamation_"
        sanitizeChar '@'  = "at_"
        sanitizeChar '#'  = "num_"
        sanitizeChar '$'  = "dollar_"
        sanitizeChar '%'  = "percent_"
        sanitizeChar '^'  = "caret_"
        sanitizeChar '&'  = "amp_"
        sanitizeChar '['  = "leftsquare_"
        sanitizeChar ']'  = "rightsquare_"
        sanitizeChar '{'  = "leftcurly_"
        sanitizeChar '}'  = "rightcurly_"
        sanitizeChar '\\' = "backslash_"
        sanitizeChar ':'  = "colon_"
        sanitizeChar ';'  = "semicolon_"
        sanitizeChar '>'  = "gt_"
        sanitizeChar '<'  = "lt_"
        sanitizeChar '='  = "equals_"
        sanitizeChar '+'  = "plus_"
        sanitizeChar '*'  = "times_"
        sanitizeChar '/'  = "div_"
        sanitizeChar c    = [c]

sanitize :: Id -> Id
sanitize i@(I _)    = i
sanitize b@(B _)    = b
sanitize v@(V _)    = v
sanitize (S str)    = S $ sanitizeStr str
sanitize (Comp ids) = Comp $ map sanitize ids

enkiId :: Stream s m Char => String -> [String] -> ParsecT s st m Id
enkiId symbols = fmap sanitize . buildExpressionParser opTable . baseEnkiId symbols . (operators ++ )

baseEnkiId :: String -> [String] -> Parser Id
baseEnkiId symbols excluded =
    Comp <$> untilFail (choice (map (try . withWs) [var, bool, int, parens symbols excluded, str symbols excluded, quoteId]))

untilFail :: Parser a -> Parser [a]
untilFail parser = do
    r <- optionMaybe parser
    case r of
        Nothing -> pure []
        Just v -> do
            rs <- untilFail parser
            pure $ v:rs

quoteId :: Parser Id
quoteId = do
    s <- between (symbol (string "\"")) (symbol (string "\"")) $ many $ noneOf "\""
    pure $ S $ "\"" ++ s ++ "\""

parens :: String -> [String] -> Parser Id
parens ignoreSymbols excluded =
         paren ignoreSymbols excluded "(" ")" id <|>
         paren ignoreSymbols excluded "[" "]" (surround (S "[") (S "]")) <|>
         paren ignoreSymbols excluded "{" "}" (surround (S "{") (S "}"))
    where
        surround start end (Comp ids) = Comp $ start:ids ++ [end]
        surround start end id         = Comp [start, id, end]

paren :: String -> [String] -> String -> String -> (Id -> Id) -> Parser Id
paren ignoreSymbols excluded start end f = f <$> try (between startGroup endGroup (enkiId (start ++ end ++ ignoreSymbols) excluded))
    where
        startGroup = string start >> wsSkip
        endGroup = wsSkip >> string end

opTable :: Stream s m Char => OperatorTable s st m Id
opTable =
    [
        [binary "^" AssocLeft],
        [binary "*" AssocLeft, binary "/" AssocLeft, binary "mod" AssocLeft],
        [binary "+" AssocLeft, binary "-" AssocLeft],
        [binary ".." AssocLeft],
        [binary "=" AssocNone],
        [binary ">=" AssocNone, binary "<=" AssocNone,
         binary "<" AssocNone, binary ">" AssocNone]
    ]

flatten (Comp [id]) = id
flatten id = id

binary :: Stream s m Char => String -> Assoc -> Operator s st m Id
binary name = Infix parse
    where
        parse = do
            op <- try $ opStr name
            pure $ \a b -> Comp [flatten a, op, flatten b]

str :: String -> [String] -> Parser Id
str ignoreSymbols list = do
    s <- letters <|> symbols -- <|> concatOp
    if s `elem` list then
        parserFail "Found item from excluded list"
    else
        pure $ S s

    where
        letters = nonEmpty ['a'..'z'] cs
        cs = ['a'..'z'] ++ ['A'..'Z'] ++ ['0'..'9'] ++ ['_']

        symbols = many1 $ oneOf $ "!@#$%^&*[]{}|\\:;>-<=+*/" \\ ignoreSymbols

nonEmpty :: String -> String -> Parser String
nonEmpty start ending = do
    s <- oneOf start
    ss <- many $ oneOf ending

    pure $ s:ss

opStr :: String -> Parser Id
opStr str = S <$> do
    s <- symbol (string str)
    pure s

exclude :: Stream s m Char => [String] -> ParsecT s st m String -> ParsecT s st m String
exclude strs parser = do
    notFollowedBy $ choice $ map (symbol . string) strs
    parser

var :: Parser Id
var = V <$> do
    s <- oneOf ['A'..'Z']
    ss <- many $ oneOf $ ['A'..'Z'] ++ ['a'..'z'] ++ ['0'..'9']

    pure $ s:ss

nonzeroDigit :: Parser Char
nonzeroDigit = oneOf "123456789"

int :: Parser Id
int = I . read <$> string "0" <|> do
    neg <- optionMaybe $ try $ string "-"
    digits <- (:) <$> nonzeroDigit <*> many digit

    pure $ I $ read $ fromMaybe "" neg ++ digits

bool :: Parser Id
bool = B . read . titleCase <$> choice [string "true", string "false"]

wsSkip :: Parser ()
wsSkip = skipMany $ oneOf " \r\t"

whitespace :: Parser ()
whitespace = skipMany1 $ oneOf " \t\n\r"

newlines :: Parser ()
newlines = skipMany1 (wsSkip >> char '\n' >> wsSkip)

symbol :: Stream s m Char => ParsecT s st m a -> ParsecT s st m a
symbol parser = do
    lineSep
    v <- parser
    lineSep
    pure v

