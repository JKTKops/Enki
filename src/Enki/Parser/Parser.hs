{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE OverloadedStrings #-}

module Enki.Parser.Parser where

import CMarkGFM

import Control.Monad.IO.Class
import Control.Monad.Trans.State.Lazy

import Data.List
import Data.Maybe
import Data.String.Utils
import qualified Data.Text as T

import System.Directory
import System.Environment
import System.FilePath.Posix

import Text.Parsec hiding (newline)
import Text.Parsec.Expr

import Enki.Types
import Enki.Parser.AST
import Enki.Parser.Util
import Enki.Parser.AST.Transformer

type Parser a = forall s st m. Stream s m Char => ParsecT s st m a

extractCode :: Node -> [String]
extractCode (Node _ (CODE_BLOCK info code) nodes)
    | info == "enki" = T.unpack code : concatMap extractCode nodes
    | otherwise = concatMap extractCode nodes
extractCode (Node _ _ nodes) = concatMap extractCode nodes

loadMarkdownFile :: String -> IO String
loadMarkdownFile filename = do
    contents <- T.pack <$> readFile filename
    let markdown = commonmarkToNode [] [] contents
    pure $ intercalate "\n" $ extractCode markdown

loadFile :: String -> IO String
loadFile filename
    | ".enki" `isSuffixOf` filename = readFile filename
    | otherwise = loadMarkdownFile filename

parseFileAst :: String -> IO [Def]
parseFileAst fname = do
    enkiPath <- getEnv "ENKI_PATH"

    -- Load the standard library
    stdLib <- withCurrentDirectory enkiPath (parseDef =<< loadFile "base.enki")

    let dir = takeDirectory fname
    let base = takeFileName fname

    res <- withCurrentDirectory dir (parseDef =<< loadFile base)

    case (stdLib, res) of
        (Left err, _) -> error $ show err
        (_, Left err) -> error $ show err
        (Right stdLibParsed, Right parsed) -> pure $ fixImports $ Module "base" stdLibParsed : parsed

fixImports :: [Def] -> [Def]
fixImports defs = filter (noIgnore (concatMap ignore defs)) defs
    where
        noIgnore _ (NoImport _) = False -- Remove all of these
        noIgnore ignoredNames (Module name _) = name `notElem` ignoredNames
        noIgnore _ _ = True

        ignore (NoImport name) = [name]
        ignore _ = []

parseDef :: MonadIO m => String -> m (Either ParseError [Def])
parseDef = fmap (fmap runTransform) <$> runParserT enkiDef () ""

enkiDef :: (MonadIO m, Stream s m Char) => ParsecT s st m [Def]
enkiDef = many (try defineAlias <|>
                try enkiImport <|>
                try noImport <|>
                try func <|>
                try rule <|>
                try dataDef <|>
                exec)

defineAlias :: (MonadIO m, Stream s m Char) => ParsecT s st m Def
defineAlias = do
    symbol $ string "define"
    symbol $ string "alias"
    idKey <- enkiId  "" ["by", "as"]
    symbol $ choice [string "by", string "as"]
    idVal <- enkiId "" []
    symbol $ string "."

    pure $ Alias idKey idVal

noImport :: (MonadIO m, Stream s m Char) => ParsecT s st m Def
noImport = do
    symbol $ string "do"
    symbol $ string "not"
    symbol $ string "use"
    moduleName <- symbol $ many $ noneOf " .\n\r\t"
    symbol $ string "."

    pure $ NoImport moduleName

enkiImport :: (MonadIO m, Stream s m Char) => ParsecT s st m Def
enkiImport = do
    symbol $ string "use"
    -- TODO: Allow defining multiple modules per file
    moduleName <- symbol $ many $ noneOf " .\n\r\t"
    file <- optionMaybe $ do
        symbol $ string "from"
        symbol $ many $ noneOf " .\n\r\t"
    symbol $ string "."

    let filename =
            case file of
                Nothing -> moduleName ++ ".enki"
                Just name -> if ".enki" `isSuffixOf` name then name else name ++ ".enki"

    -- TODO: Make this search multiple paths
    -- TODO: Also make this search the ENKI_PATH
    defs <- liftIO $ parseFileAst filename
    pure $ Module moduleName defs

exec :: Parser Def
exec = do
    c <- constraint
    symbol $ char '.'
    pure $ Exec c

rule :: Parser Def
rule = do
    tempId <- symbol $ enkiId "" ["if", "where"]

    let (id, argConstrs) = replaceCompArgs tempId

    symbol $ choice $ map string ["if", "where"]

    c <- constraint

    symbol $ char '.'

    pure $ case c of
        c@(Constraint cid) -> Rule id $ Constraints $ argConstrs ++ [c]
        Constraints cs     -> Rule id $ Constraints $ argConstrs ++ cs
        When _ _           -> error "Cannot have a rule with only a when branch for it's body, must include an otherwise!"

funcResultVar = V "AUTOGENERATEDFUNCTIONRESULT"

replaceCompArgs :: Id -> (Id, [Constraint])
replaceCompArgs (Comp ids) =
    let (newIds, constraints) = unzip $ zipWith go [1..] ids
    in (Comp newIds, concat constraints)
    where
        go counter c@(Comp _) = (V freshArgId, [Constraint (Comp [V freshArgId, S "=", c])])
            where freshArgId = "AUTOGENARG" ++ show counter
        go counter i = (i, [])
replaceCompArgs i = (i, [])

func :: Parser Def
func = do
    tempId <- symbol $ enkiId "" ["are", "is"]

    let (id, argConstrs) = replaceCompArgs tempId

    symbol $ choice [string "is", string "are"]
    constr <- symbol constraint
    symbol $ char '.'

    pure $ case constr of
        Constraint cid -> Func id (Constraints argConstrs) $ Expr cid
        Constraints cs | allWhenBranches (dropWhile (not . isWhen) cs) ->
            let ctrs = takeWhile (not . isWhen) cs
                whens = dropWhile (not . isWhen) cs
            in Func id (Constraints (argConstrs ++ ctrs ++ map makeResult whens)) $ Expr $ Comp [funcResultVar]

        Constraints cs ->
            let (Constraint cid) = last cs
            in Func id (Constraints (argConstrs ++ init cs)) $ Expr cid
        When _ _       -> error "Cannot have a function with only a when branch for it's body"

makeResult :: Constraint -> Constraint
makeResult (When cond (Constraints [])) = When (makeResult cond) $ Constraints []
makeResult (When cond body)             = When cond $ makeResult body
makeResult (Constraints cs)             = Constraints $ map go (init cs) ++ [makeResult (last cs)]
    where
        -- Need to process all the when's here to make sure we don't miss their results
        go (When cond body) = When cond $ makeResult body
        go c = c
makeResult c@(Constraint id) = Constraint $ Comp [funcResultVar, S "=", id]

isWhen (When _ _) = True
isWhen _          = False

allWhenBranches :: [Constraint] -> Bool
allWhenBranches constrs = all isWhen constrs && not (null constrs)

dataDef :: Parser Def
dataDef = do
    id <- symbol $ enkiId "" ["may", "be"]
    symbol $ string "may"
    symbol $ string "be"
    constructors <- sepBy constructor $ symbol $ string "|"
    symbol $ string "."

    pure $ Data id constructors

constructor :: Parser Constructor
constructor = try constructorWithFields <|> try unitConstructor

unitConstructor :: Parser Constructor
unitConstructor = do
    id <- enkiId "" ["is","if","where","|"] -- Don't accidentally parse functions or rules
    pure $ Constructor id []

constructorWithFields :: Parser Constructor
constructorWithFields = do
    id <- symbol $ enkiId "" ["has", "|"]
    symbol $ string "has"
    fields <- sepBy1 field $ symbol $ string ","
    pure $ Constructor id fields

field :: Parser Field
field = do
    id <- symbol $ baseEnkiId "" [":"]
    symbol $ string ":"
    t <- symbol enkiType

    pure $ Field id t

enkiType :: Parser Type
enkiType = do
    first <- singleEnkiType
    rest <- optionMaybe $ do
        sep <- choice $ map (symbol . string) ["->", "~", "*"]
        second <- enkiType
        pure $ case sep of
            "->" -> (FuncType, second)
            "~"  -> (RuleType, second)
            "*"  -> (DataType, second)

    pure $ case rest of
        Nothing -> first
        Just (constr, second) -> constr first second

singleEnkiType :: Parser Type
singleEnkiType = parenType <|> dataTypeName

dataTypeName :: Parser Type
dataTypeName = do
    id <- symbol $ baseEnkiId "" ["->", "~", "*"]
    pure $ case id of
        V s -> Any s
        S s | s == "int" -> EnkiInt
        S s | s == "string" -> EnkiString
        _ -> makeTypeName id

parenType :: Parser Type
parenType = between (symbol (string "(")) (symbol (string ")")) enkiType

connected :: String -> (Type -> Type -> Type) -> Parser Type
connected connector constr = foldl1 constr <$> sepBy1 enkiType (symbol (string connector))

expr :: Parser Expr
expr = Expr <$> enkiId "" []

constraint :: Parser Constraint
constraint = do
    constraints <- map Constraint <$> sepEndBy idParsers sep
    whenBranches <- many $ try $ when <|> otherwiseBranch

    pure $ Constraints $ constraints ++ whenBranches
    where
        ignoreWords = ["when", "then", "otherwise"]
        idParsers = do
            id <- try (enkiId "" ignoreWords) <|> try (baseEnkiId "" ignoreWords)
            case id of
                Comp [] -> parserZero
                _       -> pure id
        sep = symbol $ string ","

when :: Parser Constraint
when = do
    symbol $ string "when"
    condition <- constraint

    symbol $ string "then"
    body <- constraint

    symbol $ char '.'

    pure $ When condition body

otherwiseBranch :: Parser Constraint
otherwiseBranch = do
    symbol $ string "otherwise"
    symbol $ string "then"
    body <- constraint

    pure $ When body $ Constraints []

withWs :: Stream s m Char => ParsecT s st m a -> ParsecT s st m a
withWs parser = do
    a <- parser
    wsSkip
    pure a

operators = ["!=", "=", "+", "-", "<=", ">=", "*", "/", "^", "..", "<", ">"]

sanitizeStr :: String -> String

-- We can't directly use the strings "true" and "false", because those are reserved in Prolog
sanitizeStr "true" = "enki_true"
sanitizeStr "false" = "enki_false"

sanitizeStr str
    | str `elem` operators = str
    | otherwise = fst $ foldl go ("", False) str
    where
        go (cur, inQuotes) c
            | c == '\"' = (cur ++ "\"", not inQuotes)
            | inQuotes  = (cur ++ [c], inQuotes)
            | otherwise = (cur ++ sanitizeChar c, inQuotes)

        sanitizeChar '|'  = "pipe_"
        sanitizeChar '-'  = "dash_"
        sanitizeChar '!'  = "exclamation_"
        sanitizeChar '@'  = "at_"
        sanitizeChar '#'  = "num_"
        sanitizeChar '$'  = "dollar_"
        sanitizeChar '%'  = "percent_"
        sanitizeChar '^'  = "caret_"
        sanitizeChar '&'  = "amp_"
        sanitizeChar '['  = "leftsquare_"
        sanitizeChar ']'  = "rightsquare_"
        sanitizeChar '{'  = "leftcurly_"
        sanitizeChar '}'  = "rightcurly_"
        sanitizeChar '\\' = "backslash_"
        sanitizeChar ':'  = "colon_"
        sanitizeChar ';'  = "semicolon_"
        sanitizeChar '>'  = "gt_"
        sanitizeChar '<'  = "lt_"
        sanitizeChar '='  = "equals_"
        sanitizeChar '+'  = "plus_"
        sanitizeChar '*'  = "times_"
        sanitizeChar '/'  = "div_"
        sanitizeChar c    = [c]

sanitize :: Id -> Id
sanitize i@(I _)    = i
sanitize v@(V _)    = v
sanitize (S str)    = S $ sanitizeStr str
sanitize (Comp ids) = Comp $ map sanitize ids

enkiId :: Stream s m Char => String -> [String] -> ParsecT s st m Id
enkiId symbols = fmap sanitize . buildExpressionParser opTable . baseEnkiId symbols . (operators ++ )

baseEnkiId :: String -> [String] -> Parser Id
baseEnkiId symbols excluded = do
    ids <- untilFail $ choice $ map withWs [var, int, parens symbols excluded, try (str symbols excluded), quoteId]
    pure $ case ids of
        [i] -> i
        xs -> Comp xs

untilFail :: Parser a -> Parser [a]
untilFail parser = do
    r <- optionMaybe parser
    case r of
        Nothing -> pure []
        Just v -> do
            rs <- untilFail parser
            pure $ v:rs

quoteId :: Parser Id
quoteId = do
    s <- between (symbol (string "\"")) (symbol (string "\"")) $ many $ noneOf "\""
    pure $ S $ "\"" ++ s ++ "\""

parens :: String -> [String] -> Parser Id
parens ignoreSymbols excluded =
         paren ignoreSymbols excluded "(" ")" id <|>
         paren ignoreSymbols excluded "[" "]" (surround (S "[") (S "]")) <|>
         paren ignoreSymbols excluded "{" "}" (surround (S "{") (S "}"))
    where
        surround start end (Comp ids) = Comp $ start:ids ++ [end]
        surround start end id         = Comp [start, id, end]

paren :: String -> [String] -> String -> String -> (Id -> Id) -> Parser Id
paren ignoreSymbols excluded start end f = f <$> try (between startGroup endGroup (enkiId (start ++ end ++ ignoreSymbols) excluded))
    where
        startGroup = string start >> wsSkip
        endGroup = wsSkip >> string end

opTable :: Stream s m Char => OperatorTable s st m Id
opTable =
    [
        [prefix "-"],
        [binary "^" AssocLeft],
        [binary "*" AssocLeft, binary "/" AssocLeft, binary "mod" AssocLeft],
        [binary "+" AssocLeft, binary "-" AssocLeft],
        [binary ".." AssocLeft],
        [binary "!=" AssocNone, binary "=" AssocNone],
        [binary ">=" AssocNone, binary "<=" AssocNone,
         binary "<" AssocNone, binary ">" AssocNone]
    ]

flatten (Comp [id]) = id
flatten id = id

prefix :: Stream s m Char => String -> Operator s st m Id
prefix name = Prefix $ do
    op <- try $ opStr name
    pure $ \a -> Comp [op, flatten a]

binary :: Stream s m Char => String -> Assoc -> Operator s st m Id
binary name = Infix $ do
    op <- try $ opStr name
    pure $ \a b -> Comp [flatten a, op, flatten b]

str :: String -> [String] -> Parser Id
str ignoreSymbols list = do
    s <- letters <|> symbols -- <|> concatOp
    if s `elem` list then
        parserFail "Found item from excluded list"
    else
        pure $ S $ processEscape s

    where
        letters = nonEmpty ('`' : ['a'..'z']) cs
        cs = ['a'..'z'] ++ ['A'..'Z'] ++ ['0'..'9'] ++ ['_']

        symbols = many1 $ oneOf $ "`!@#$%^&*[]{}|\\:;>-<=+*/" \\ ignoreSymbols

        -- We use backquotes to allow defining names that use otherwise reserved identitiers like "is"
        processEscape [] = []
        processEscape ('`':'`':xs) = '`' : processEscape xs
        processEscape ('`':xs) = processEscape xs
        processEscape (x:xs) = x : processEscape xs

nonEmpty :: String -> String -> Parser String
nonEmpty start ending = do
    s <- oneOf start
    ss <- many $ oneOf ending

    pure $ s:ss

opStr :: String -> Parser Id
opStr str = S <$> symbol (string str)

exclude :: Stream s m Char => [String] -> ParsecT s st m String -> ParsecT s st m String
exclude strs parser = do
    notFollowedBy $ choice $ map (symbol . string) strs
    parser

var :: Parser Id
var = V <$> do
    s <- oneOf $ '_' : ['A'..'Z']
    ss <- many $ oneOf $ '_' : ['A'..'Z'] ++ ['a'..'z'] ++ ['0'..'9']

    pure $ s:ss

int :: Parser Id
int = I . read <$> many1 digit

wsSkip :: Parser ()
wsSkip = skipMany $ oneOf " \r\t"

skip p = p >> pure ()

lineSep :: Parser ()
lineSep = skipMany (skip (oneOf " \r\t\n") <|> try comment)

comment :: Parser ()
comment = do
    -- Consume as many characters as possible after seeing "--"
    string "--"
    many $ noneOf "\n"
    pure ()

symbol :: Stream s m Char => ParsecT s st m a -> ParsecT s st m a
symbol parser = do
    lineSep
    v <- parser
    lineSep
    pure v

