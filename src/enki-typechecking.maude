load enki-syntax.maude

mod ENKI-TYPECHECK-SORTS-SYNTAX is
    protecting ENKI-SYNTAX .
    protecting LIST{EnkiType} .
    protecting MAP{String, Id} .

    sorts TypedFunc TypedId TypedExpr .

    op tid : Id EnkiType -> TypedId .
    op typedExpr : TypedId -> TypedExpr .
    op typedf : Id EnkiType TypedExpr -> TypedFunc .

    op fcall : Id List{EnkiType} Map{String, Id} -> Id .
endm

view TypedId from TRIV to ENKI-TYPECHECK-SORTS-SYNTAX is
    sort Elt to TypedId .
endv

view TypedFunc from TRIV to ENKI-TYPECHECK-SORTS-SYNTAX is
    sort Elt to TypedFunc .
endv

mod ENKI-TYPECHECK-SORTS is
    protecting ENKI-TYPECHECK-SORTS-SYNTAX .
    protecting SET{TypedId} .
    protecting LIST{TypedId} .
endm

mod ENKI-TYPECHECK is
    protecting ENKI-SYNTAX .
    protecting ENKI-TYPECHECK-SORTS .

    protecting LIST{EnkiFunc} .
    protecting LIST{TypedFunc} .

    protecting SET{EnkiType} .

    protecting CONVERSION .

    vars S S1 S2 : String .
    var I : Int .
    var B : Bool .
    vars Id Id1 Id2 : Id .
    var Ids : List{Id} .

    vars T T1 T2 : EnkiType .
    vars TID TID1 TID2 : TypedId .
    vars TIDS TIDS1 TIDS2 : Set{TypedId} .
    var L : List{TypedId} .

    var Ts : Set{EnkiType} .

    op firstUnused : Set{EnkiType} Int -> EnkiType .
    eq firstUnused(Ts, I) =
        if any("T" + string(I, 10)) in Ts then firstUnused(Ts, I + 1) else any("T" + string(I, 10)) fi .

    op types : Set{TypedId} -> Set{EnkiType} .
    eq types(empty)              = empty .
    eq types((tid(Id, T), TIDS)) = (T, types(TIDS)) .

    op freshtype : Set{TypedId} Id -> Set{TypedId} .
    eq freshtype(TIDS, Id) = (tid(Id, firstUnused(types(TIDS), 0)), TIDS) .

    op freshtypes : Set{TypedId} List{Id} -> Set{TypedId} .
    eq freshtypes(TIDS, nil)                    = TIDS .
    eq freshtypes((tid(Id, T), TIDS), (Id Ids)) = freshtypes((tid(Id, T), TIDS), Ids) .
    eq freshtypes(TIDS, (v(S) Ids))             = freshtypes(freshtype(TIDS, v(S)), Ids) .
    eq freshtypes(TIDS, (i(I) Ids))             = freshtypes((tid(i(I), int), TIDS), Ids) .
    eq freshtypes(TIDS, (b(B) Ids))             = freshtypes((tid(b(B), bool), TIDS), Ids) .
    eq freshtypes(TIDS, (s(S) Ids))             = freshtypes((tid(s(S), string), TIDS), Ids) .

    op typeSet : List{TypedId} -> Set{TypedId} .
    eq typeSet(nil)          = empty .
    eq typeSet(tid(Id, T) L) = (tid(Id, T), typeSet(L)) .

    op typeof : Set{TypedId} Id -> EnkiType .
    eq typeof((tid(Id, T), TIDS), Id) = T .
    eq typeof(TIDS, Id) = firstUnused(types(TIDS), 0) [owise] .

    op attachType : Set{TypedId} Id -> TypedId .
    eq attachType(TIDS, Id) = tid(Id, typeof(TIDS, Id)) .

    op attachVars : Set{TypedId} List{Id} -> List{TypedId} .
    eq attachVars(TIDS, nil)                    = nil .
    ceq attachVars(TIDS, (Id Ids)) = tid(Id, T) attachVars((tid(Id, T), TIDS), Ids)
        if T := typeof(TIDS, Id) .

    op functype : NeList{TypedId} -> EnkiType .
    eq functype(tid(Id, T))   = T .
    eq functype(tid(Id, T) L) = func(T, functype(L)) .

    op join : EnkiType EnkiType -> EnkiType [comm] .
    eq join(any(S), T) = T .
    eq join(T, T)      = T .

    op unifyAll : Set{TypedId} EnkiType EnkiType -> Set{TypedId} .
    eq unifyAll(empty, T1, T2) = empty .
    eq unifyAll((tid(Id, T1), TIDS), T1, T2) = (tid(Id, T2), unifyAll(TIDS, T1, T2)) .
    eq unifyAll(TIDS, T1, T2) = TIDS [owise] .

    op unify : Set{TypedId} Id Id -> Set{TypedId} .
    ceq unify(TIDS, Id1, Id2) = unifyAll(unifyAll(TIDS, T1, T), T2, T)
        if (tid(Id1, T1), tid(Id2, T2), TIDS2) := TIDS /\
           T := join(T1, T2) .
    eq unify(TIDS, Id1, Id2) = (tid(Id1, typeof(TIDS, Id2)), TIDS) .

    op unifyType : Set{TypedId} Id EnkiType -> Set{TypedId} .
    eq unifyType((tid(Id, T1), TIDS), Id, T2) = unifyAll((tid(Id, T1), TIDS), T1, join(T1, T2)) .
    eq unifyType(TIDS, Id, T2) = (tid(Id, T2), TIDS) [owise] .

    var Types : List{EnkiType} .
    op unifyList : Set{TypedId} List{EnkiType} List{Id} -> Set{TypedId} .
    eq unifyList(TIDS, Types, nil)      = TIDS .
    eq unifyList(TIDS, T Types, Id Ids) = unifyList(unifyType(TIDS, Id, T), Types, Ids) .

    op isArith : String -> Bool .
    eq isArith("+") = true .
    eq isArith("-") = true .
    eq isArith("/") = true .
    eq isArith("*") = true .
    eq isArith("^") = true .
    eq isArith(S)   = false [owise] .

    op funcTypeList : EnkiType -> List{EnkiType} .
    eq funcTypeList(func(T1, T2)) = T1 funcTypeList(T2) .
    eq funcTypeList(T)            = T [owise] .

    vars Ids1 Ids2 : List{Id} .
    op funcNameMatches : Id Id -> Bool .
    eq funcNameMatches(v(S), Id) = true .
    eq funcNameMatches(s(S), s(S)) = true .
    eq funcNameMatches(comp(nil), comp(nil)) = true .
    eq funcNameMatches(comp(Id1 Ids1), comp(Id2 Ids2)) = funcNameMatches(Id1, Id2) and funcNameMatches(comp(Ids1), comp(Ids2)) .

    op funcUnify : Id Id -> Map{String, Id} .
    eq funcUnify(v(S), Id) = S |-> Id .
    eq funcUnify(s(S), s(S)) = empty .
    eq funcUnify(comp(nil), comp(nil)) = empty .
    eq funcUnify(comp(Id1 Ids1), comp(Id2 Ids2)) = funcUnify(Id1, Id2), funcUnify(comp(Ids1), comp(Ids2)) .

    op findFuncType : Set{TypedId} Id -> TypedId .
    ceq findFuncType((tid(fid(Id1), T), TIDS), Id2) = tid(Id1, T)
        if funcNameMatches(Id1, Id2) .

    var FuncType : EnkiType .
    op inferId : Set{TypedId} Id -> Set{TypedId} .
    ceq inferId(TIDS, Id) = unify(unify(TIDS, Id1, Id2), Id, Id1)
        if comp(Id1 s("=") Id2) := Id .
    ceq inferId(TIDS, Id) = unify(unify(unifyType(TIDS, Id1, int), Id1, Id2), Id, Id1)
        if comp(Id1 s(S) Id2) := Id /\
           isArith(S) .
    ceq inferId(TIDS, Id) = unifyType(unifyList(TIDS, Types, Ids), Id, T)
        if tid(Id1, FuncType) := findFuncType(TIDS, Id) /\
           Ids                := varlist(Id)            /\
           T                  := returnType(FuncType)   /\
           Types              := funcTypeList(FuncType) .
    eq inferId(TIDS, Id) = TIDS [owise] .

    op makeFuncType : Set{TypedId} Id Id -> EnkiType .
    eq makeFuncType(TIDS, Id1, Id2) = functype(attachVars(TIDS, varlist(Id1)) attachType(TIDS, Id2)) .

    var VarMap : Map{String, Id} .

    var DummyT : EnkiType .
    var ResolvedId : Id .

    op resolveMap : Set{TypedId} Map{String, Id} -> Map{String, Id} .
    eq resolveMap(TIDS, empty) = empty .
    ceq resolveMap(TIDS, (S |-> Id, VarMap)) = (S |-> ResolvedId, resolveMap(TIDS, VarMap))
        if DummyT := firstUnused(types(TIDS), 0) /\
           tid(ResolvedId, DummyT) := resolve(TIDS, tid(Id, DummyT)) .

    var RestTIDS : Set{TypedId} .
    var FuncId : Id .

    op resolve : Set{TypedId} TypedId -> TypedId .
    eq resolve(TIDS,  tid(v(S), T))     = tid(v(S), T) .
    eq resolve(TIDS,  tid(b(B), T))     = tid(b(B), T) .
    eq resolve(TIDS,  tid(i(I), T))     = tid(i(I), T) .
    eq resolve(TIDS,  tid(s(S), T))     = tid(s(S), T) .
    ceq resolve(TIDS, tid(t(Id, T), T)) = tid(t(Id1, T), T)
        if tid(Id1, T1) := resolve(TIDS, tid(Id, T)) .
    eq resolve(TIDS,  tid(comp(nil), T)) = tid(comp(nil), T) .
    --- Lookup the function call, if applicable
    ceq resolve(TIDS, tid(comp(Ids), T1)) = tid(fcall(FuncId, funcTypeList(T), resolveMap(TIDS, VarMap)), T1)
        if (tid(fid(FuncId), T), RestTIDS) := TIDS /\
           VarMap                          := funcUnify(FuncId, comp(Ids)) /\
           funcNameMatches(FuncId, comp(Ids)) .
    --- Otherwise, resolve each in sequence (important for things like "X + Y")
    ceq resolve(TIDS, tid(comp(Id Ids), T1)) = tid(prependIds(Id1, Id2), T1)
        --- Generate a new dummy types (if necessary)
        if DummyT := firstUnused(types(TIDS), 0) /\
           tid(Id1, DummyT) := resolve(TIDS, tid(Id, DummyT)) /\
           tid(Id2, DummyT) := resolve(TIDS, tid(comp(Ids), DummyT)) .

    var Expr : Expr .
    var NewTIDS : Set{TypedId} .
    op inferFunc : Set{TypedId} EnkiFunc -> TypedFunc .
    ceq inferFunc(TIDS, f(Id1, e(Id2))) = typedf(Id1, makeFuncType(NewTIDS, Id1, Id2), TExpr)
        if NewTIDS := inferId(freshtypes(TIDS, append(idList(Id1), idList(Id2))), Id2) /\
           TExpr := typedExpr(resolve(NewTIDS, attachType(NewTIDS, Id2))) .

    var Func : EnkiFunc .
    var Funcs : List{EnkiFunc} .
    var TFunc : TypedFunc .
    var TExpr : TypedExpr .
    op inferFuncs : Set{TypedId} List{EnkiFunc} -> List{TypedFunc} .
    eq inferFuncs(TIDS, nil) = nil .
    ceq inferFuncs(TIDS, f(Id1, e(Id2)) Funcs) = TFunc inferFuncs((tid(fid(Id), T), TIDS), Funcs)
        if TFunc := inferFunc(TIDS, f(Id1, e(Id2))) /\
           typedf(Id, T, TExpr) := TFunc .
endm

